{"version":3,"sources":["turbopack:///[project]/HandS/frontend/app/projects/[projectId]/notionRendering.tsx/__nextjs-internal-proxy.mjs","turbopack:///[project]/HandS/frontend/node_modules/eventemitter3/index.js","turbopack:///[project]/HandS/frontend/node_modules/mimic-function/index.js","turbopack:///[project]/HandS/frontend/node_modules/normalize-url/index.js","turbopack:///[project]/HandS/frontend/node_modules/ofetch/dist/node.mjs","turbopack:///[project]/HandS/frontend/node_modules/node-fetch-native/dist/index.mjs","turbopack:///[project]/HandS/frontend/node_modules/destr/dist/index.mjs","turbopack:///[project]/HandS/frontend/node_modules/ufo/dist/index.mjs","turbopack:///[project]/HandS/frontend/app/projects/[projectId]/page.tsx","turbopack:///[project]/HandS/frontend/node_modules/eventemitter3/index.mjs","turbopack:///[project]/HandS/frontend/node_modules/p-timeout/index.js","turbopack:///[project]/HandS/frontend/node_modules/is-url-superb/index.js","turbopack:///[project]/HandS/frontend/node_modules/p-map/index.js","turbopack:///[project]/HandS/frontend/node_modules/memoize/distribution/index.js","turbopack:///[project]/HandS/frontend/node_modules/p-queue/dist/priority-queue.js","turbopack:///[project]/HandS/frontend/node_modules/p-queue/dist/lower-bound.js","turbopack:///[project]/HandS/frontend/node_modules/ofetch/dist/shared/ofetch.03887fc3.mjs","turbopack:///[project]/HandS/frontend/node_modules/p-queue/dist/index.js","turbopack:///[project]/HandS/frontend/node_modules/notion-utils/build/index.js","turbopack:///[project]/HandS/frontend/node_modules/notion-client/build/index.js"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport default registerClientReference(\n    function() { throw new Error(\"Attempted to call the default export of [project]/HandS/frontend/app/projects/[projectId]/notionRendering.tsx from the server, but it's on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/HandS/frontend/app/projects/[projectId]/notionRendering.tsx\",\n    \"default\",\n);\n","'use strict';\n\nvar has = Object.prototype.hasOwnProperty\n  , prefix = '~';\n\n/**\n * Constructor to create a storage for our `EE` objects.\n * An `Events` instance is a plain object whose properties are event names.\n *\n * @constructor\n * @private\n */\nfunction Events() {}\n\n//\n// We try to not inherit from `Object.prototype`. In some engines creating an\n// instance in this way is faster than calling `Object.create(null)` directly.\n// If `Object.create(null)` is not supported we prefix the event names with a\n// character to make sure that the built-in object properties are not\n// overridden or used as an attack vector.\n//\nif (Object.create) {\n  Events.prototype = Object.create(null);\n\n  //\n  // This hack is needed because the `__proto__` property is still inherited in\n  // some old browsers like Android 4, iPhone 5.1, Opera 11 and Safari 5.\n  //\n  if (!new Events().__proto__) prefix = false;\n}\n\n/**\n * Representation of a single event listener.\n *\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} [once=false] Specify if the listener is a one-time listener.\n * @constructor\n * @private\n */\nfunction EE(fn, context, once) {\n  this.fn = fn;\n  this.context = context;\n  this.once = once || false;\n}\n\n/**\n * Add a listener for a given event.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} context The context to invoke the listener with.\n * @param {Boolean} once Specify if the listener is a one-time listener.\n * @returns {EventEmitter}\n * @private\n */\nfunction addListener(emitter, event, fn, context, once) {\n  if (typeof fn !== 'function') {\n    throw new TypeError('The listener must be a function');\n  }\n\n  var listener = new EE(fn, context || emitter, once)\n    , evt = prefix ? prefix + event : event;\n\n  if (!emitter._events[evt]) emitter._events[evt] = listener, emitter._eventsCount++;\n  else if (!emitter._events[evt].fn) emitter._events[evt].push(listener);\n  else emitter._events[evt] = [emitter._events[evt], listener];\n\n  return emitter;\n}\n\n/**\n * Clear event by name.\n *\n * @param {EventEmitter} emitter Reference to the `EventEmitter` instance.\n * @param {(String|Symbol)} evt The Event name.\n * @private\n */\nfunction clearEvent(emitter, evt) {\n  if (--emitter._eventsCount === 0) emitter._events = new Events();\n  else delete emitter._events[evt];\n}\n\n/**\n * Minimal `EventEmitter` interface that is molded against the Node.js\n * `EventEmitter` interface.\n *\n * @constructor\n * @public\n */\nfunction EventEmitter() {\n  this._events = new Events();\n  this._eventsCount = 0;\n}\n\n/**\n * Return an array listing the events for which the emitter has registered\n * listeners.\n *\n * @returns {Array}\n * @public\n */\nEventEmitter.prototype.eventNames = function eventNames() {\n  var names = []\n    , events\n    , name;\n\n  if (this._eventsCount === 0) return names;\n\n  for (name in (events = this._events)) {\n    if (has.call(events, name)) names.push(prefix ? name.slice(1) : name);\n  }\n\n  if (Object.getOwnPropertySymbols) {\n    return names.concat(Object.getOwnPropertySymbols(events));\n  }\n\n  return names;\n};\n\n/**\n * Return the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Array} The registered listeners.\n * @public\n */\nEventEmitter.prototype.listeners = function listeners(event) {\n  var evt = prefix ? prefix + event : event\n    , handlers = this._events[evt];\n\n  if (!handlers) return [];\n  if (handlers.fn) return [handlers.fn];\n\n  for (var i = 0, l = handlers.length, ee = new Array(l); i < l; i++) {\n    ee[i] = handlers[i].fn;\n  }\n\n  return ee;\n};\n\n/**\n * Return the number of listeners listening to a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Number} The number of listeners.\n * @public\n */\nEventEmitter.prototype.listenerCount = function listenerCount(event) {\n  var evt = prefix ? prefix + event : event\n    , listeners = this._events[evt];\n\n  if (!listeners) return 0;\n  if (listeners.fn) return 1;\n  return listeners.length;\n};\n\n/**\n * Calls each of the listeners registered for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @returns {Boolean} `true` if the event had listeners, else `false`.\n * @public\n */\nEventEmitter.prototype.emit = function emit(event, a1, a2, a3, a4, a5) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return false;\n\n  var listeners = this._events[evt]\n    , len = arguments.length\n    , args\n    , i;\n\n  if (listeners.fn) {\n    if (listeners.once) this.removeListener(event, listeners.fn, undefined, true);\n\n    switch (len) {\n      case 1: return listeners.fn.call(listeners.context), true;\n      case 2: return listeners.fn.call(listeners.context, a1), true;\n      case 3: return listeners.fn.call(listeners.context, a1, a2), true;\n      case 4: return listeners.fn.call(listeners.context, a1, a2, a3), true;\n      case 5: return listeners.fn.call(listeners.context, a1, a2, a3, a4), true;\n      case 6: return listeners.fn.call(listeners.context, a1, a2, a3, a4, a5), true;\n    }\n\n    for (i = 1, args = new Array(len -1); i < len; i++) {\n      args[i - 1] = arguments[i];\n    }\n\n    listeners.fn.apply(listeners.context, args);\n  } else {\n    var length = listeners.length\n      , j;\n\n    for (i = 0; i < length; i++) {\n      if (listeners[i].once) this.removeListener(event, listeners[i].fn, undefined, true);\n\n      switch (len) {\n        case 1: listeners[i].fn.call(listeners[i].context); break;\n        case 2: listeners[i].fn.call(listeners[i].context, a1); break;\n        case 3: listeners[i].fn.call(listeners[i].context, a1, a2); break;\n        case 4: listeners[i].fn.call(listeners[i].context, a1, a2, a3); break;\n        default:\n          if (!args) for (j = 1, args = new Array(len -1); j < len; j++) {\n            args[j - 1] = arguments[j];\n          }\n\n          listeners[i].fn.apply(listeners[i].context, args);\n      }\n    }\n  }\n\n  return true;\n};\n\n/**\n * Add a listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.on = function on(event, fn, context) {\n  return addListener(this, event, fn, context, false);\n};\n\n/**\n * Add a one-time listener for a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn The listener function.\n * @param {*} [context=this] The context to invoke the listener with.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.once = function once(event, fn, context) {\n  return addListener(this, event, fn, context, true);\n};\n\n/**\n * Remove the listeners of a given event.\n *\n * @param {(String|Symbol)} event The event name.\n * @param {Function} fn Only remove the listeners that match this function.\n * @param {*} context Only remove the listeners that have this context.\n * @param {Boolean} once Only remove one-time listeners.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeListener = function removeListener(event, fn, context, once) {\n  var evt = prefix ? prefix + event : event;\n\n  if (!this._events[evt]) return this;\n  if (!fn) {\n    clearEvent(this, evt);\n    return this;\n  }\n\n  var listeners = this._events[evt];\n\n  if (listeners.fn) {\n    if (\n      listeners.fn === fn &&\n      (!once || listeners.once) &&\n      (!context || listeners.context === context)\n    ) {\n      clearEvent(this, evt);\n    }\n  } else {\n    for (var i = 0, events = [], length = listeners.length; i < length; i++) {\n      if (\n        listeners[i].fn !== fn ||\n        (once && !listeners[i].once) ||\n        (context && listeners[i].context !== context)\n      ) {\n        events.push(listeners[i]);\n      }\n    }\n\n    //\n    // Reset the array, or remove it completely if we have no more listeners.\n    //\n    if (events.length) this._events[evt] = events.length === 1 ? events[0] : events;\n    else clearEvent(this, evt);\n  }\n\n  return this;\n};\n\n/**\n * Remove all listeners, or those of the specified event.\n *\n * @param {(String|Symbol)} [event] The event name.\n * @returns {EventEmitter} `this`.\n * @public\n */\nEventEmitter.prototype.removeAllListeners = function removeAllListeners(event) {\n  var evt;\n\n  if (event) {\n    evt = prefix ? prefix + event : event;\n    if (this._events[evt]) clearEvent(this, evt);\n  } else {\n    this._events = new Events();\n    this._eventsCount = 0;\n  }\n\n  return this;\n};\n\n//\n// Alias methods names because people roll like that.\n//\nEventEmitter.prototype.off = EventEmitter.prototype.removeListener;\nEventEmitter.prototype.addListener = EventEmitter.prototype.on;\n\n//\n// Expose the prefix.\n//\nEventEmitter.prefixed = prefix;\n\n//\n// Allow `EventEmitter` to be imported as module namespace.\n//\nEventEmitter.EventEmitter = EventEmitter;\n\n//\n// Expose the module.\n//\nif ('undefined' !== typeof module) {\n  module.exports = EventEmitter;\n}\n","const copyProperty = (to, from, property, ignoreNonConfigurable) => {\n\t// `Function#length` should reflect the parameters of `to` not `from` since we keep its body.\n\t// `Function#prototype` is non-writable and non-configurable so can never be modified.\n\tif (property === 'length' || property === 'prototype') {\n\t\treturn;\n\t}\n\n\t// `Function#arguments` and `Function#caller` should not be copied. They were reported to be present in `Reflect.ownKeys` for some devices in React Native (#41), so we explicitly ignore them here.\n\tif (property === 'arguments' || property === 'caller') {\n\t\treturn;\n\t}\n\n\tconst toDescriptor = Object.getOwnPropertyDescriptor(to, property);\n\tconst fromDescriptor = Object.getOwnPropertyDescriptor(from, property);\n\n\tif (!canCopyProperty(toDescriptor, fromDescriptor) && ignoreNonConfigurable) {\n\t\treturn;\n\t}\n\n\tObject.defineProperty(to, property, fromDescriptor);\n};\n\n// `Object.defineProperty()` throws if the property exists, is not configurable and either:\n// - one its descriptors is changed\n// - it is non-writable and its value is changed\nconst canCopyProperty = function (toDescriptor, fromDescriptor) {\n\treturn toDescriptor === undefined || toDescriptor.configurable || (\n\t\ttoDescriptor.writable === fromDescriptor.writable\n\t\t&& toDescriptor.enumerable === fromDescriptor.enumerable\n\t\t&& toDescriptor.configurable === fromDescriptor.configurable\n\t\t&& (toDescriptor.writable || toDescriptor.value === fromDescriptor.value)\n\t);\n};\n\nconst changePrototype = (to, from) => {\n\tconst fromPrototype = Object.getPrototypeOf(from);\n\tif (fromPrototype === Object.getPrototypeOf(to)) {\n\t\treturn;\n\t}\n\n\tObject.setPrototypeOf(to, fromPrototype);\n};\n\nconst wrappedToString = (withName, fromBody) => `/* Wrapped ${withName}*/\\n${fromBody}`;\n\nconst toStringDescriptor = Object.getOwnPropertyDescriptor(Function.prototype, 'toString');\nconst toStringName = Object.getOwnPropertyDescriptor(Function.prototype.toString, 'name');\n\n// We call `from.toString()` early (not lazily) to ensure `from` can be garbage collected.\n// We use `bind()` instead of a closure for the same reason.\n// Calling `from.toString()` early also allows caching it in case `to.toString()` is called several times.\nconst changeToString = (to, from, name) => {\n\tconst withName = name === '' ? '' : `with ${name.trim()}() `;\n\tconst newToString = wrappedToString.bind(null, withName, from.toString());\n\t// Ensure `to.toString.toString` is non-enumerable and has the same `same`\n\tObject.defineProperty(newToString, 'name', toStringName);\n\tconst {writable, enumerable, configurable} = toStringDescriptor; // We destructue to avoid a potential `get` descriptor.\n\tObject.defineProperty(to, 'toString', {value: newToString, writable, enumerable, configurable});\n};\n\nexport default function mimicFunction(to, from, {ignoreNonConfigurable = false} = {}) {\n\tconst {name} = to;\n\n\tfor (const property of Reflect.ownKeys(from)) {\n\t\tcopyProperty(to, from, property, ignoreNonConfigurable);\n\t}\n\n\tchangePrototype(to, from);\n\tchangeToString(to, from, name);\n\n\treturn to;\n}\n","// https://developer.mozilla.org/en-US/docs/Web/HTTP/Basics_of_HTTP/Data_URIs\nconst DATA_URL_DEFAULT_MIME_TYPE = 'text/plain';\nconst DATA_URL_DEFAULT_CHARSET = 'us-ascii';\n\nconst testParameter = (name, filters) => filters.some(filter => filter instanceof RegExp ? filter.test(name) : filter === name);\n\nconst supportedProtocols = new Set([\n\t'https:',\n\t'http:',\n\t'file:',\n]);\n\nconst hasCustomProtocol = urlString => {\n\ttry {\n\t\tconst {protocol} = new URL(urlString);\n\n\t\treturn protocol.endsWith(':')\n\t\t\t&& !protocol.includes('.')\n\t\t\t&& !supportedProtocols.has(protocol);\n\t} catch {\n\t\treturn false;\n\t}\n};\n\nconst normalizeDataURL = (urlString, {stripHash}) => {\n\tconst match = /^data:(?<type>[^,]*?),(?<data>[^#]*?)(?:#(?<hash>.*))?$/.exec(urlString);\n\n\tif (!match) {\n\t\tthrow new Error(`Invalid URL: ${urlString}`);\n\t}\n\n\tlet {type, data, hash} = match.groups;\n\tconst mediaType = type.split(';');\n\thash = stripHash ? '' : hash;\n\n\tlet isBase64 = false;\n\tif (mediaType[mediaType.length - 1] === 'base64') {\n\t\tmediaType.pop();\n\t\tisBase64 = true;\n\t}\n\n\t// Lowercase MIME type\n\tconst mimeType = mediaType.shift()?.toLowerCase() ?? '';\n\tconst attributes = mediaType\n\t\t.map(attribute => {\n\t\t\tlet [key, value = ''] = attribute.split('=').map(string => string.trim());\n\n\t\t\t// Lowercase `charset`\n\t\t\tif (key === 'charset') {\n\t\t\t\tvalue = value.toLowerCase();\n\n\t\t\t\tif (value === DATA_URL_DEFAULT_CHARSET) {\n\t\t\t\t\treturn '';\n\t\t\t\t}\n\t\t\t}\n\n\t\t\treturn `${key}${value ? `=${value}` : ''}`;\n\t\t})\n\t\t.filter(Boolean);\n\n\tconst normalizedMediaType = [\n\t\t...attributes,\n\t];\n\n\tif (isBase64) {\n\t\tnormalizedMediaType.push('base64');\n\t}\n\n\tif (normalizedMediaType.length > 0 || (mimeType && mimeType !== DATA_URL_DEFAULT_MIME_TYPE)) {\n\t\tnormalizedMediaType.unshift(mimeType);\n\t}\n\n\treturn `data:${normalizedMediaType.join(';')},${isBase64 ? data.trim() : data}${hash ? `#${hash}` : ''}`;\n};\n\nexport default function normalizeUrl(urlString, options) {\n\toptions = {\n\t\tdefaultProtocol: 'http',\n\t\tnormalizeProtocol: true,\n\t\tforceHttp: false,\n\t\tforceHttps: false,\n\t\tstripAuthentication: true,\n\t\tstripHash: false,\n\t\tstripTextFragment: true,\n\t\tstripWWW: true,\n\t\tremoveQueryParameters: [/^utm_\\w+/i],\n\t\tremoveTrailingSlash: true,\n\t\tremoveSingleSlash: true,\n\t\tremoveDirectoryIndex: false,\n\t\tremoveExplicitPort: false,\n\t\tsortQueryParameters: true,\n\t\tremovePath: false,\n\t\ttransformPath: false,\n\t\t...options,\n\t};\n\n\t// Legacy: Append `:` to the protocol if missing.\n\tif (typeof options.defaultProtocol === 'string' && !options.defaultProtocol.endsWith(':')) {\n\t\toptions.defaultProtocol = `${options.defaultProtocol}:`;\n\t}\n\n\turlString = urlString.trim();\n\n\t// Data URL\n\tif (/^data:/i.test(urlString)) {\n\t\treturn normalizeDataURL(urlString, options);\n\t}\n\n\tif (hasCustomProtocol(urlString)) {\n\t\treturn urlString;\n\t}\n\n\tconst hasRelativeProtocol = urlString.startsWith('//');\n\tconst isRelativeUrl = !hasRelativeProtocol && /^\\.*\\//.test(urlString);\n\n\t// Prepend protocol\n\tif (!isRelativeUrl) {\n\t\turlString = urlString.replace(/^(?!(?:\\w+:)?\\/\\/)|^\\/\\//, options.defaultProtocol);\n\t}\n\n\tconst urlObject = new URL(urlString);\n\n\tif (options.forceHttp && options.forceHttps) {\n\t\tthrow new Error('The `forceHttp` and `forceHttps` options cannot be used together');\n\t}\n\n\tif (options.forceHttp && urlObject.protocol === 'https:') {\n\t\turlObject.protocol = 'http:';\n\t}\n\n\tif (options.forceHttps && urlObject.protocol === 'http:') {\n\t\turlObject.protocol = 'https:';\n\t}\n\n\t// Remove auth\n\tif (options.stripAuthentication) {\n\t\turlObject.username = '';\n\t\turlObject.password = '';\n\t}\n\n\t// Remove hash\n\tif (options.stripHash) {\n\t\turlObject.hash = '';\n\t} else if (options.stripTextFragment) {\n\t\turlObject.hash = urlObject.hash.replace(/#?:~:text.*?$/i, '');\n\t}\n\n\t// Remove duplicate slashes if not preceded by a protocol\n\t// NOTE: This could be implemented using a single negative lookbehind\n\t// regex, but we avoid that to maintain compatibility with older js engines\n\t// which do not have support for that feature.\n\tif (urlObject.pathname) {\n\t\t// TODO: Replace everything below with `urlObject.pathname = urlObject.pathname.replace(/(?<!\\b[a-z][a-z\\d+\\-.]{1,50}:)\\/{2,}/g, '/');` when Safari supports negative lookbehind.\n\n\t\t// Split the string by occurrences of this protocol regex, and perform\n\t\t// duplicate-slash replacement on the strings between those occurrences\n\t\t// (if any).\n\t\tconst protocolRegex = /\\b[a-z][a-z\\d+\\-.]{1,50}:\\/\\//g;\n\n\t\tlet lastIndex = 0;\n\t\tlet result = '';\n\t\tfor (;;) {\n\t\t\tconst match = protocolRegex.exec(urlObject.pathname);\n\t\t\tif (!match) {\n\t\t\t\tbreak;\n\t\t\t}\n\n\t\t\tconst protocol = match[0];\n\t\t\tconst protocolAtIndex = match.index;\n\t\t\tconst intermediate = urlObject.pathname.slice(lastIndex, protocolAtIndex);\n\n\t\t\tresult += intermediate.replace(/\\/{2,}/g, '/');\n\t\t\tresult += protocol;\n\t\t\tlastIndex = protocolAtIndex + protocol.length;\n\t\t}\n\n\t\tconst remnant = urlObject.pathname.slice(lastIndex, urlObject.pathname.length);\n\t\tresult += remnant.replace(/\\/{2,}/g, '/');\n\n\t\turlObject.pathname = result;\n\t}\n\n\t// Decode URI octets\n\tif (urlObject.pathname) {\n\t\ttry {\n\t\t\turlObject.pathname = decodeURI(urlObject.pathname).replace(/\\\\/g, '%5C');\n\t\t} catch {}\n\t}\n\n\t// Remove directory index\n\tif (options.removeDirectoryIndex === true) {\n\t\toptions.removeDirectoryIndex = [/^index\\.[a-z]+$/];\n\t}\n\n\tif (Array.isArray(options.removeDirectoryIndex) && options.removeDirectoryIndex.length > 0) {\n\t\tlet pathComponents = urlObject.pathname.split('/');\n\t\tconst lastComponent = pathComponents[pathComponents.length - 1];\n\n\t\tif (testParameter(lastComponent, options.removeDirectoryIndex)) {\n\t\t\tpathComponents = pathComponents.slice(0, -1);\n\t\t\turlObject.pathname = pathComponents.slice(1).join('/') + '/';\n\t\t}\n\t}\n\n\t// Remove path\n\tif (options.removePath) {\n\t\turlObject.pathname = '/';\n\t}\n\n\t// Transform path components\n\tif (options.transformPath && typeof options.transformPath === 'function') {\n\t\tconst pathComponents = urlObject.pathname.split('/').filter(Boolean);\n\t\tconst newComponents = options.transformPath(pathComponents);\n\t\turlObject.pathname = newComponents?.length > 0 ? `/${newComponents.join('/')}` : '/';\n\t}\n\n\tif (urlObject.hostname) {\n\t\t// Remove trailing dot\n\t\turlObject.hostname = urlObject.hostname.replace(/\\.$/, '');\n\n\t\t// Remove `www.`\n\t\tif (options.stripWWW && /^www\\.(?!www\\.)[a-z\\-\\d]{1,63}\\.[a-z.\\-\\d]{2,63}$/.test(urlObject.hostname)) {\n\t\t\t// Each label should be max 63 at length (min: 1).\n\t\t\t// Source: https://en.wikipedia.org/wiki/Hostname#Restrictions_on_valid_host_names\n\t\t\t// Each TLD should be up to 63 characters long (min: 2).\n\t\t\t// It is technically possible to have a single character TLD, but none currently exist.\n\t\t\turlObject.hostname = urlObject.hostname.replace(/^www\\./, '');\n\t\t}\n\t}\n\n\t// Remove query unwanted parameters\n\tif (Array.isArray(options.removeQueryParameters)) {\n\t\t// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.\n\t\tfor (const key of [...urlObject.searchParams.keys()]) {\n\t\t\tif (testParameter(key, options.removeQueryParameters)) {\n\t\t\t\turlObject.searchParams.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\tif (!Array.isArray(options.keepQueryParameters) && options.removeQueryParameters === true) {\n\t\turlObject.search = '';\n\t}\n\n\t// Keep wanted query parameters\n\tif (Array.isArray(options.keepQueryParameters) && options.keepQueryParameters.length > 0) {\n\t\t// eslint-disable-next-line unicorn/no-useless-spread -- We are intentionally spreading to get a copy.\n\t\tfor (const key of [...urlObject.searchParams.keys()]) {\n\t\t\tif (!testParameter(key, options.keepQueryParameters)) {\n\t\t\t\turlObject.searchParams.delete(key);\n\t\t\t}\n\t\t}\n\t}\n\n\t// Sort query parameters\n\tif (options.sortQueryParameters) {\n\t\tconst originalSearch = urlObject.search;\n\t\turlObject.searchParams.sort();\n\n\t\t// Calling `.sort()` encodes the search parameters, so we need to decode them again.\n\t\ttry {\n\t\t\turlObject.search = decodeURIComponent(urlObject.search);\n\t\t} catch {}\n\n\t\t// Fix parameters that originally had no equals sign but got one added by URLSearchParams\n\t\tconst partsWithoutEquals = originalSearch.slice(1).split('&').filter(p => p && !p.includes('='));\n\t\tfor (const part of partsWithoutEquals) {\n\t\t\tconst decoded = decodeURIComponent(part);\n\t\t\t// Only replace at word boundaries to avoid partial matches\n\t\t\turlObject.search = urlObject.search.replace(`?${decoded}=`, `?${decoded}`).replace(`&${decoded}=`, `&${decoded}`);\n\t\t}\n\t}\n\n\tif (options.removeTrailingSlash) {\n\t\turlObject.pathname = urlObject.pathname.replace(/\\/$/, '');\n\t}\n\n\t// Remove an explicit port number, excluding a default port number, if applicable\n\tif (options.removeExplicitPort && urlObject.port) {\n\t\turlObject.port = '';\n\t}\n\n\tconst oldUrlString = urlString;\n\n\t// Take advantage of many of the Node `url` normalizations\n\turlString = urlObject.toString();\n\n\tif (!options.removeSingleSlash && urlObject.pathname === '/' && !oldUrlString.endsWith('/') && urlObject.hash === '') {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Remove ending `/` unless removeSingleSlash is false\n\tif ((options.removeTrailingSlash || urlObject.pathname === '/') && urlObject.hash === '' && options.removeSingleSlash) {\n\t\turlString = urlString.replace(/\\/$/, '');\n\t}\n\n\t// Restore relative protocol, if applicable\n\tif (hasRelativeProtocol && !options.normalizeProtocol) {\n\t\turlString = urlString.replace(/^http:\\/\\//, '//');\n\t}\n\n\t// Remove http/https\n\tif (options.stripProtocol) {\n\t\turlString = urlString.replace(/^(?:https?:)?\\/\\//, '');\n\t}\n\n\treturn urlString;\n}\n","import http from 'node:http';\nimport https from 'node:https';\nimport nodeFetch, { Headers as Headers$1, AbortController as AbortController$1 } from 'node-fetch-native';\nimport { c as createFetch } from './shared/ofetch.03887fc3.mjs';\nexport { F as FetchError, a as createFetchError } from './shared/ofetch.03887fc3.mjs';\nimport 'destr';\nimport 'ufo';\n\nfunction createNodeFetch() {\n  const useKeepAlive = JSON.parse(process.env.FETCH_KEEP_ALIVE || \"false\");\n  if (!useKeepAlive) {\n    return nodeFetch;\n  }\n  const agentOptions = { keepAlive: true };\n  const httpAgent = new http.Agent(agentOptions);\n  const httpsAgent = new https.Agent(agentOptions);\n  const nodeFetchOptions = {\n    agent(parsedURL) {\n      return parsedURL.protocol === \"http:\" ? httpAgent : httpsAgent;\n    }\n  };\n  return function nodeFetchWithKeepAlive(input, init) {\n    return nodeFetch(input, { ...nodeFetchOptions, ...init });\n  };\n}\nconst fetch = globalThis.fetch ? (...args) => globalThis.fetch(...args) : createNodeFetch();\nconst Headers = globalThis.Headers || Headers$1;\nconst AbortController = globalThis.AbortController || AbortController$1;\nconst ofetch = createFetch({ fetch, Headers, AbortController });\nconst $fetch = ofetch;\n\nexport { $fetch, AbortController, Headers, createFetch, createNodeFetch, fetch, ofetch };\n","import{fetch as e,Blob as t,File as s,FormData as l,Headers as a,Request as i,Response as b,AbortController as m}from\"./node.mjs\";export{AbortError,FetchError,blobFrom,blobFromSync,fileFrom,fileFromSync,isRedirect}from\"./node.mjs\";import\"node:http\";import\"node:https\";import\"node:zlib\";import\"node:stream\";import\"node:buffer\";import\"node:util\";import\"./shared/node-fetch-native.DfbY2q-x.mjs\";import\"node:url\";import\"node:net\";import\"node:fs\";import\"node:path\";const o=!!globalThis.process?.env?.FORCE_NODE_FETCH,r=!o&&globalThis.fetch||e,p=!o&&globalThis.Blob||t,F=!o&&globalThis.File||s,h=!o&&globalThis.FormData||l,n=!o&&globalThis.Headers||a,c=!o&&globalThis.Request||i,R=!o&&globalThis.Response||b,T=!o&&globalThis.AbortController||m;export{T as AbortController,p as Blob,F as File,h as FormData,n as Headers,c as Request,R as Response,r as default,r as fetch};\n","const suspectProtoRx = /\"(?:_|\\\\u0{2}5[Ff]){2}(?:p|\\\\u0{2}70)(?:r|\\\\u0{2}72)(?:o|\\\\u0{2}6[Ff])(?:t|\\\\u0{2}74)(?:o|\\\\u0{2}6[Ff])(?:_|\\\\u0{2}5[Ff]){2}\"\\s*:/;\nconst suspectConstructorRx = /\"(?:c|\\\\u0063)(?:o|\\\\u006[Ff])(?:n|\\\\u006[Ee])(?:s|\\\\u0073)(?:t|\\\\u0074)(?:r|\\\\u0072)(?:u|\\\\u0075)(?:c|\\\\u0063)(?:t|\\\\u0074)(?:o|\\\\u006[Ff])(?:r|\\\\u0072)\"\\s*:/;\nconst JsonSigRx = /^\\s*[\"[{]|^\\s*-?\\d{1,16}(\\.\\d{1,17})?([Ee][+-]?\\d+)?\\s*$/;\nfunction jsonParseTransform(key, value) {\n  if (key === \"__proto__\" || key === \"constructor\" && value && typeof value === \"object\" && \"prototype\" in value) {\n    warnKeyDropped(key);\n    return;\n  }\n  return value;\n}\nfunction warnKeyDropped(key) {\n  console.warn(`[destr] Dropping \"${key}\" key to prevent prototype pollution.`);\n}\nfunction destr(value, options = {}) {\n  if (typeof value !== \"string\") {\n    return value;\n  }\n  if (value[0] === '\"' && value[value.length - 1] === '\"' && value.indexOf(\"\\\\\") === -1) {\n    return value.slice(1, -1);\n  }\n  const _value = value.trim();\n  if (_value.length <= 9) {\n    switch (_value.toLowerCase()) {\n      case \"true\": {\n        return true;\n      }\n      case \"false\": {\n        return false;\n      }\n      case \"undefined\": {\n        return void 0;\n      }\n      case \"null\": {\n        return null;\n      }\n      case \"nan\": {\n        return Number.NaN;\n      }\n      case \"infinity\": {\n        return Number.POSITIVE_INFINITY;\n      }\n      case \"-infinity\": {\n        return Number.NEGATIVE_INFINITY;\n      }\n    }\n  }\n  if (!JsonSigRx.test(value)) {\n    if (options.strict) {\n      throw new SyntaxError(\"[destr] Invalid JSON\");\n    }\n    return value;\n  }\n  try {\n    if (suspectProtoRx.test(value) || suspectConstructorRx.test(value)) {\n      if (options.strict) {\n        throw new Error(\"[destr] Possible prototype pollution\");\n      }\n      return JSON.parse(value, jsonParseTransform);\n    }\n    return JSON.parse(value);\n  } catch (error) {\n    if (options.strict) {\n      throw error;\n    }\n    return value;\n  }\n}\nfunction safeDestr(value, options = {}) {\n  return destr(value, { ...options, strict: true });\n}\n\nexport { destr as default, destr, safeDestr };\n","const n = /[^\\0-\\x7E]/;\nconst t = /[\\x2E\\u3002\\uFF0E\\uFF61]/g;\nconst o = {\n  overflow: \"Overflow Error\",\n  \"not-basic\": \"Illegal Input\",\n  \"invalid-input\": \"Invalid Input\"\n};\nconst e = Math.floor;\nconst r = String.fromCharCode;\nfunction s(n2) {\n  throw new RangeError(o[n2]);\n}\nconst c = function(n2, t2) {\n  return n2 + 22 + 75 * (n2 < 26) - ((t2 != 0) << 5);\n};\nconst u = function(n2, t2, o2) {\n  let r2 = 0;\n  for (n2 = o2 ? e(n2 / 700) : n2 >> 1, n2 += e(n2 / t2); n2 > 455; r2 += 36) {\n    n2 = e(n2 / 35);\n  }\n  return e(r2 + 36 * n2 / (n2 + 38));\n};\nfunction toASCII(o2) {\n  return function(n2, o3) {\n    const e2 = n2.split(\"@\");\n    let r2 = \"\";\n    e2.length > 1 && (r2 = e2[0] + \"@\", n2 = e2[1]);\n    const s2 = function(n3, t2) {\n      const o4 = [];\n      let e3 = n3.length;\n      for (; e3--; ) {\n        o4[e3] = t2(n3[e3]);\n      }\n      return o4;\n    }((n2 = n2.replace(t, \".\")).split(\".\"), o3).join(\".\");\n    return r2 + s2;\n  }(o2, function(t2) {\n    return n.test(t2) ? \"xn--\" + function(n2) {\n      const t3 = [];\n      const o3 = (n2 = function(n3) {\n        const t4 = [];\n        let o4 = 0;\n        const e2 = n3.length;\n        for (; o4 < e2; ) {\n          const r2 = n3.charCodeAt(o4++);\n          if (r2 >= 55296 && r2 <= 56319 && o4 < e2) {\n            const e3 = n3.charCodeAt(o4++);\n            (64512 & e3) == 56320 ? t4.push(((1023 & r2) << 10) + (1023 & e3) + 65536) : (t4.push(r2), o4--);\n          } else {\n            t4.push(r2);\n          }\n        }\n        return t4;\n      }(n2)).length;\n      let f = 128;\n      let i = 0;\n      let l = 72;\n      for (const o4 of n2) {\n        o4 < 128 && t3.push(r(o4));\n      }\n      const h = t3.length;\n      let p = h;\n      for (h && t3.push(\"-\"); p < o3; ) {\n        let o4 = 2147483647;\n        for (const t4 of n2) {\n          t4 >= f && t4 < o4 && (o4 = t4);\n        }\n        const a = p + 1;\n        o4 - f > e((2147483647 - i) / a) && s(\"overflow\"), i += (o4 - f) * a, f = o4;\n        for (const o5 of n2) {\n          if (o5 < f && ++i > 2147483647 && s(\"overflow\"), o5 == f) {\n            let n3 = i;\n            for (let o6 = 36; ; o6 += 36) {\n              const s2 = o6 <= l ? 1 : o6 >= l + 26 ? 26 : o6 - l;\n              if (n3 < s2) {\n                break;\n              }\n              const u2 = n3 - s2;\n              const f2 = 36 - s2;\n              t3.push(r(c(s2 + u2 % f2, 0))), n3 = e(u2 / f2);\n            }\n            t3.push(r(c(n3, 0))), l = u(i, a, p == h), i = 0, ++p;\n          }\n        }\n        ++i, ++f;\n      }\n      return t3.join(\"\");\n    }(t2) : t2;\n  });\n}\n\nconst HASH_RE = /#/g;\nconst AMPERSAND_RE = /&/g;\nconst SLASH_RE = /\\//g;\nconst EQUAL_RE = /=/g;\nconst IM_RE = /\\?/g;\nconst PLUS_RE = /\\+/g;\nconst ENC_CARET_RE = /%5e/gi;\nconst ENC_BACKTICK_RE = /%60/gi;\nconst ENC_CURLY_OPEN_RE = /%7b/gi;\nconst ENC_PIPE_RE = /%7c/gi;\nconst ENC_CURLY_CLOSE_RE = /%7d/gi;\nconst ENC_SPACE_RE = /%20/gi;\nconst ENC_SLASH_RE = /%2f/gi;\nconst ENC_ENC_SLASH_RE = /%252f/gi;\nfunction encode(text) {\n  return encodeURI(\"\" + text).replace(ENC_PIPE_RE, \"|\");\n}\nfunction encodeHash(text) {\n  return encode(text).replace(ENC_CURLY_OPEN_RE, \"{\").replace(ENC_CURLY_CLOSE_RE, \"}\").replace(ENC_CARET_RE, \"^\");\n}\nfunction encodeQueryValue(input) {\n  return encode(typeof input === \"string\" ? input : JSON.stringify(input)).replace(PLUS_RE, \"%2B\").replace(ENC_SPACE_RE, \"+\").replace(HASH_RE, \"%23\").replace(AMPERSAND_RE, \"%26\").replace(ENC_BACKTICK_RE, \"`\").replace(ENC_CARET_RE, \"^\").replace(SLASH_RE, \"%2F\");\n}\nfunction encodeQueryKey(text) {\n  return encodeQueryValue(text).replace(EQUAL_RE, \"%3D\");\n}\nfunction encodePath(text) {\n  return encode(text).replace(HASH_RE, \"%23\").replace(IM_RE, \"%3F\").replace(ENC_ENC_SLASH_RE, \"%2F\").replace(AMPERSAND_RE, \"%26\").replace(PLUS_RE, \"%2B\");\n}\nfunction encodeParam(text) {\n  return encodePath(text).replace(SLASH_RE, \"%2F\");\n}\nfunction decode(text = \"\") {\n  try {\n    return decodeURIComponent(\"\" + text);\n  } catch {\n    return \"\" + text;\n  }\n}\nfunction decodePath(text) {\n  return decode(text.replace(ENC_SLASH_RE, \"%252F\"));\n}\nfunction decodeQueryKey(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction decodeQueryValue(text) {\n  return decode(text.replace(PLUS_RE, \" \"));\n}\nfunction encodeHost(name = \"\") {\n  return toASCII(name);\n}\n\nfunction parseQuery(parametersString = \"\") {\n  const object = /* @__PURE__ */ Object.create(null);\n  if (parametersString[0] === \"?\") {\n    parametersString = parametersString.slice(1);\n  }\n  for (const parameter of parametersString.split(\"&\")) {\n    const s = parameter.match(/([^=]+)=?(.*)/) || [];\n    if (s.length < 2) {\n      continue;\n    }\n    const key = decodeQueryKey(s[1]);\n    if (key === \"__proto__\" || key === \"constructor\") {\n      continue;\n    }\n    const value = decodeQueryValue(s[2] || \"\");\n    if (object[key] === void 0) {\n      object[key] = value;\n    } else if (Array.isArray(object[key])) {\n      object[key].push(value);\n    } else {\n      object[key] = [object[key], value];\n    }\n  }\n  return object;\n}\nfunction encodeQueryItem(key, value) {\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    value = String(value);\n  }\n  if (!value) {\n    return encodeQueryKey(key);\n  }\n  if (Array.isArray(value)) {\n    return value.map(\n      (_value) => `${encodeQueryKey(key)}=${encodeQueryValue(_value)}`\n    ).join(\"&\");\n  }\n  return `${encodeQueryKey(key)}=${encodeQueryValue(value)}`;\n}\nfunction stringifyQuery(query) {\n  return Object.keys(query).filter((k) => query[k] !== void 0).map((k) => encodeQueryItem(k, query[k])).filter(Boolean).join(\"&\");\n}\n\nconst PROTOCOL_STRICT_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{1,2})/;\nconst PROTOCOL_REGEX = /^[\\s\\w\\0+.-]{2,}:([/\\\\]{2})?/;\nconst PROTOCOL_RELATIVE_REGEX = /^([/\\\\]\\s*){2,}[^/\\\\]/;\nconst PROTOCOL_SCRIPT_RE = /^[\\s\\0]*(blob|data|javascript|vbscript):$/i;\nconst TRAILING_SLASH_RE = /\\/$|\\/\\?|\\/#/;\nconst JOIN_LEADING_SLASH_RE = /^\\.?\\//;\nfunction isRelative(inputString) {\n  return [\"./\", \"../\"].some((string_) => inputString.startsWith(string_));\n}\nfunction hasProtocol(inputString, opts = {}) {\n  if (typeof opts === \"boolean\") {\n    opts = { acceptRelative: opts };\n  }\n  if (opts.strict) {\n    return PROTOCOL_STRICT_REGEX.test(inputString);\n  }\n  return PROTOCOL_REGEX.test(inputString) || (opts.acceptRelative ? PROTOCOL_RELATIVE_REGEX.test(inputString) : false);\n}\nfunction isScriptProtocol(protocol) {\n  return !!protocol && PROTOCOL_SCRIPT_RE.test(protocol);\n}\nfunction hasTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\");\n  }\n  return TRAILING_SLASH_RE.test(input);\n}\nfunction withoutTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return (hasTrailingSlash(input) ? input.slice(0, -1) : input) || \"/\";\n  }\n  if (!hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex !== -1) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n  }\n  const [s0, ...s] = path.split(\"?\");\n  const cleanPath = s0.endsWith(\"/\") ? s0.slice(0, -1) : s0;\n  return (cleanPath || \"/\") + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction withTrailingSlash(input = \"\", respectQueryAndFragment) {\n  if (!respectQueryAndFragment) {\n    return input.endsWith(\"/\") ? input : input + \"/\";\n  }\n  if (hasTrailingSlash(input, true)) {\n    return input || \"/\";\n  }\n  let path = input;\n  let fragment = \"\";\n  const fragmentIndex = input.indexOf(\"#\");\n  if (fragmentIndex !== -1) {\n    path = input.slice(0, fragmentIndex);\n    fragment = input.slice(fragmentIndex);\n    if (!path) {\n      return fragment;\n    }\n  }\n  const [s0, ...s] = path.split(\"?\");\n  return s0 + \"/\" + (s.length > 0 ? `?${s.join(\"?\")}` : \"\") + fragment;\n}\nfunction hasLeadingSlash(input = \"\") {\n  return input.startsWith(\"/\");\n}\nfunction withoutLeadingSlash(input = \"\") {\n  return (hasLeadingSlash(input) ? input.slice(1) : input) || \"/\";\n}\nfunction withLeadingSlash(input = \"\") {\n  return hasLeadingSlash(input) ? input : \"/\" + input;\n}\nfunction cleanDoubleSlashes(input = \"\") {\n  return input.split(\"://\").map((string_) => string_.replace(/\\/{2,}/g, \"/\")).join(\"://\");\n}\nfunction withBase(input, base) {\n  if (isEmptyURL(base) || hasProtocol(input)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (input.startsWith(_base)) {\n    return input;\n  }\n  return joinURL(_base, input);\n}\nfunction withoutBase(input, base) {\n  if (isEmptyURL(base)) {\n    return input;\n  }\n  const _base = withoutTrailingSlash(base);\n  if (!input.startsWith(_base)) {\n    return input;\n  }\n  const trimmed = input.slice(_base.length);\n  return trimmed[0] === \"/\" ? trimmed : \"/\" + trimmed;\n}\nfunction withQuery(input, query) {\n  const parsed = parseURL(input);\n  const mergedQuery = { ...parseQuery(parsed.search), ...query };\n  parsed.search = stringifyQuery(mergedQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction filterQuery(input, predicate) {\n  if (!input.includes(\"?\")) {\n    return input;\n  }\n  const parsed = parseURL(input);\n  const query = parseQuery(parsed.search);\n  const filteredQuery = Object.fromEntries(\n    Object.entries(query).filter(([key, value]) => predicate(key, value))\n  );\n  parsed.search = stringifyQuery(filteredQuery);\n  return stringifyParsedURL(parsed);\n}\nfunction getQuery(input) {\n  return parseQuery(parseURL(input).search);\n}\nfunction isEmptyURL(url) {\n  return !url || url === \"/\";\n}\nfunction isNonEmptyURL(url) {\n  return url && url !== \"/\";\n}\nfunction joinURL(base, ...input) {\n  let url = base || \"\";\n  for (const segment of input.filter((url2) => isNonEmptyURL(url2))) {\n    if (url) {\n      const _segment = segment.replace(JOIN_LEADING_SLASH_RE, \"\");\n      url = withTrailingSlash(url) + _segment;\n    } else {\n      url = segment;\n    }\n  }\n  return url;\n}\nfunction joinRelativeURL(..._input) {\n  const JOIN_SEGMENT_SPLIT_RE = /\\/(?!\\/)/;\n  const input = _input.filter(Boolean);\n  const segments = [];\n  let segmentsDepth = 0;\n  for (const i of input) {\n    if (!i || i === \"/\") {\n      continue;\n    }\n    for (const [sindex, s] of i.split(JOIN_SEGMENT_SPLIT_RE).entries()) {\n      if (!s || s === \".\") {\n        continue;\n      }\n      if (s === \"..\") {\n        if (segments.length === 1 && hasProtocol(segments[0])) {\n          continue;\n        }\n        segments.pop();\n        segmentsDepth--;\n        continue;\n      }\n      if (sindex === 1 && segments[segments.length - 1]?.endsWith(\":/\")) {\n        segments[segments.length - 1] += \"/\" + s;\n        continue;\n      }\n      segments.push(s);\n      segmentsDepth++;\n    }\n  }\n  let url = segments.join(\"/\");\n  if (segmentsDepth >= 0) {\n    if (input[0]?.startsWith(\"/\") && !url.startsWith(\"/\")) {\n      url = \"/\" + url;\n    } else if (input[0]?.startsWith(\"./\") && !url.startsWith(\"./\")) {\n      url = \"./\" + url;\n    }\n  } else {\n    url = \"../\".repeat(-1 * segmentsDepth) + url;\n  }\n  if (input[input.length - 1]?.endsWith(\"/\") && !url.endsWith(\"/\")) {\n    url += \"/\";\n  }\n  return url;\n}\nfunction withHttp(input) {\n  return withProtocol(input, \"http://\");\n}\nfunction withHttps(input) {\n  return withProtocol(input, \"https://\");\n}\nfunction withoutProtocol(input) {\n  return withProtocol(input, \"\");\n}\nfunction withProtocol(input, protocol) {\n  let match = input.match(PROTOCOL_REGEX);\n  if (!match) {\n    match = input.match(/^\\/{2,}/);\n  }\n  if (!match) {\n    return protocol + input;\n  }\n  return protocol + input.slice(match[0].length);\n}\nfunction normalizeURL(input) {\n  const parsed = parseURL(input);\n  parsed.pathname = encodePath(decodePath(parsed.pathname));\n  parsed.hash = encodeHash(decode(parsed.hash));\n  parsed.host = encodeHost(decode(parsed.host));\n  parsed.search = stringifyQuery(parseQuery(parsed.search));\n  return stringifyParsedURL(parsed);\n}\nfunction resolveURL(base = \"\", ...inputs) {\n  if (typeof base !== \"string\") {\n    throw new TypeError(\n      `URL input should be string received ${typeof base} (${base})`\n    );\n  }\n  const filteredInputs = inputs.filter((input) => isNonEmptyURL(input));\n  if (filteredInputs.length === 0) {\n    return base;\n  }\n  const url = parseURL(base);\n  for (const inputSegment of filteredInputs) {\n    const urlSegment = parseURL(inputSegment);\n    if (urlSegment.pathname) {\n      url.pathname = withTrailingSlash(url.pathname) + withoutLeadingSlash(urlSegment.pathname);\n    }\n    if (urlSegment.hash && urlSegment.hash !== \"#\") {\n      url.hash = urlSegment.hash;\n    }\n    if (urlSegment.search && urlSegment.search !== \"?\") {\n      if (url.search && url.search !== \"?\") {\n        const queryString = stringifyQuery({\n          ...parseQuery(url.search),\n          ...parseQuery(urlSegment.search)\n        });\n        url.search = queryString.length > 0 ? \"?\" + queryString : \"\";\n      } else {\n        url.search = urlSegment.search;\n      }\n    }\n  }\n  return stringifyParsedURL(url);\n}\nfunction isSamePath(p1, p2) {\n  return decode(withoutTrailingSlash(p1)) === decode(withoutTrailingSlash(p2));\n}\nfunction isEqual(a, b, options = {}) {\n  if (!options.trailingSlash) {\n    a = withTrailingSlash(a);\n    b = withTrailingSlash(b);\n  }\n  if (!options.leadingSlash) {\n    a = withLeadingSlash(a);\n    b = withLeadingSlash(b);\n  }\n  if (!options.encoding) {\n    a = decode(a);\n    b = decode(b);\n  }\n  return a === b;\n}\nfunction withFragment(input, hash) {\n  if (!hash || hash === \"#\") {\n    return input;\n  }\n  const parsed = parseURL(input);\n  parsed.hash = hash === \"\" ? \"\" : \"#\" + encodeHash(hash);\n  return stringifyParsedURL(parsed);\n}\nfunction withoutFragment(input) {\n  return stringifyParsedURL({ ...parseURL(input), hash: \"\" });\n}\nfunction withoutHost(input) {\n  const parsed = parseURL(input);\n  return (parsed.pathname || \"/\") + parsed.search + parsed.hash;\n}\n\nconst protocolRelative = Symbol.for(\"ufo:protocolRelative\");\nfunction parseURL(input = \"\", defaultProto) {\n  const _specialProtoMatch = input.match(\n    /^[\\s\\0]*(blob:|data:|javascript:|vbscript:)(.*)/i\n  );\n  if (_specialProtoMatch) {\n    const [, _proto, _pathname = \"\"] = _specialProtoMatch;\n    return {\n      protocol: _proto.toLowerCase(),\n      pathname: _pathname,\n      href: _proto + _pathname,\n      auth: \"\",\n      host: \"\",\n      search: \"\",\n      hash: \"\"\n    };\n  }\n  if (!hasProtocol(input, { acceptRelative: true })) {\n    return defaultProto ? parseURL(defaultProto + input) : parsePath(input);\n  }\n  const [, protocol = \"\", auth, hostAndPath = \"\"] = input.replace(/\\\\/g, \"/\").match(/^[\\s\\0]*([\\w+.-]{2,}:)?\\/\\/([^/@]+@)?(.*)/) || [];\n  let [, host = \"\", path = \"\"] = hostAndPath.match(/([^#/?]*)(.*)?/) || [];\n  if (protocol === \"file:\") {\n    path = path.replace(/\\/(?=[A-Za-z]:)/, \"\");\n  }\n  const { pathname, search, hash } = parsePath(path);\n  return {\n    protocol: protocol.toLowerCase(),\n    auth: auth ? auth.slice(0, Math.max(0, auth.length - 1)) : \"\",\n    host,\n    pathname,\n    search,\n    hash,\n    [protocolRelative]: !protocol\n  };\n}\nfunction parsePath(input = \"\") {\n  const [pathname = \"\", search = \"\", hash = \"\"] = (input.match(/([^#?]*)(\\?[^#]*)?(#.*)?/) || []).splice(1);\n  return {\n    pathname,\n    search,\n    hash\n  };\n}\nfunction parseAuth(input = \"\") {\n  const [username, password] = input.split(\":\");\n  return {\n    username: decode(username),\n    password: decode(password)\n  };\n}\nfunction parseHost(input = \"\") {\n  const [hostname, port] = (input.match(/([^/:]*):?(\\d+)?/) || []).splice(1);\n  return {\n    hostname: decode(hostname),\n    port\n  };\n}\nfunction stringifyParsedURL(parsed) {\n  const pathname = parsed.pathname || \"\";\n  const search = parsed.search ? (parsed.search.startsWith(\"?\") ? \"\" : \"?\") + parsed.search : \"\";\n  const hash = parsed.hash || \"\";\n  const auth = parsed.auth ? parsed.auth + \"@\" : \"\";\n  const host = parsed.host || \"\";\n  const proto = parsed.protocol || parsed[protocolRelative] ? (parsed.protocol || \"\") + \"//\" : \"\";\n  return proto + auth + host + pathname + search + hash;\n}\nconst FILENAME_STRICT_REGEX = /\\/([^/]+\\.[^/]+)$/;\nconst FILENAME_REGEX = /\\/([^/]+)$/;\nfunction parseFilename(input = \"\", opts) {\n  const { pathname } = parseURL(input);\n  const matches = opts?.strict ? pathname.match(FILENAME_STRICT_REGEX) : pathname.match(FILENAME_REGEX);\n  return matches ? matches[1] : void 0;\n}\n\nclass $URL {\n  protocol;\n  host;\n  auth;\n  pathname;\n  query = {};\n  hash;\n  constructor(input = \"\") {\n    if (typeof input !== \"string\") {\n      throw new TypeError(\n        `URL input should be string received ${typeof input} (${input})`\n      );\n    }\n    const parsed = parseURL(input);\n    this.protocol = decode(parsed.protocol);\n    this.host = decode(parsed.host);\n    this.auth = decode(parsed.auth);\n    this.pathname = decodePath(parsed.pathname);\n    this.query = parseQuery(parsed.search);\n    this.hash = decode(parsed.hash);\n  }\n  get hostname() {\n    return parseHost(this.host).hostname;\n  }\n  get port() {\n    return parseHost(this.host).port || \"\";\n  }\n  get username() {\n    return parseAuth(this.auth).username;\n  }\n  get password() {\n    return parseAuth(this.auth).password || \"\";\n  }\n  get hasProtocol() {\n    return this.protocol.length;\n  }\n  get isAbsolute() {\n    return this.hasProtocol || this.pathname[0] === \"/\";\n  }\n  get search() {\n    const q = stringifyQuery(this.query);\n    return q.length > 0 ? \"?\" + q : \"\";\n  }\n  get searchParams() {\n    const p = new URLSearchParams();\n    for (const name in this.query) {\n      const value = this.query[name];\n      if (Array.isArray(value)) {\n        for (const v of value) {\n          p.append(name, v);\n        }\n      } else {\n        p.append(\n          name,\n          typeof value === \"string\" ? value : JSON.stringify(value)\n        );\n      }\n    }\n    return p;\n  }\n  get origin() {\n    return (this.protocol ? this.protocol + \"//\" : \"\") + encodeHost(this.host);\n  }\n  get fullpath() {\n    return encodePath(this.pathname) + this.search + encodeHash(this.hash);\n  }\n  get encodedAuth() {\n    if (!this.auth) {\n      return \"\";\n    }\n    const { username, password } = parseAuth(this.auth);\n    return encodeURIComponent(username) + (password ? \":\" + encodeURIComponent(password) : \"\");\n  }\n  get href() {\n    const auth = this.encodedAuth;\n    const originWithAuth = (this.protocol ? this.protocol + \"//\" : \"\") + (auth ? auth + \"@\" : \"\") + encodeHost(this.host);\n    return this.hasProtocol && this.isAbsolute ? originWithAuth + this.fullpath : this.fullpath;\n  }\n  append(url) {\n    if (url.hasProtocol) {\n      throw new Error(\"Cannot append a URL with protocol\");\n    }\n    Object.assign(this.query, url.query);\n    if (url.pathname) {\n      this.pathname = withTrailingSlash(this.pathname) + withoutLeadingSlash(url.pathname);\n    }\n    if (url.hash) {\n      this.hash = url.hash;\n    }\n  }\n  toJSON() {\n    return this.href;\n  }\n  toString() {\n    return this.href;\n  }\n}\nfunction createURL(input) {\n  return new $URL(input);\n}\n\nexport { $URL, cleanDoubleSlashes, createURL, decode, decodePath, decodeQueryKey, decodeQueryValue, encode, encodeHash, encodeHost, encodeParam, encodePath, encodeQueryItem, encodeQueryKey, encodeQueryValue, filterQuery, getQuery, hasLeadingSlash, hasProtocol, hasTrailingSlash, isEmptyURL, isEqual, isNonEmptyURL, isRelative, isSamePath, isScriptProtocol, joinRelativeURL, joinURL, normalizeURL, parseAuth, parseFilename, parseHost, parsePath, parseQuery, parseURL, resolveURL, stringifyParsedURL, stringifyQuery, withBase, withFragment, withHttp, withHttps, withLeadingSlash, withProtocol, withQuery, withTrailingSlash, withoutBase, withoutFragment, withoutHost, withoutLeadingSlash, withoutProtocol, withoutTrailingSlash };\n","import ProjectView from \"./notionRendering\"\r\nimport Link from \"next/link\";\r\nimport { NotionAPI } from \"notion-client\";\r\n\r\nconst API_BASE = \"http://127.0.0.1:8000\";\r\nconst notion = new NotionAPI({\r\n  activeUser: process.env.NOTION_ACTIVE_USER,\r\n  authToken: process.env.NOTION_TOKEN_V2\r\n})\r\n\r\nexport default async function Projects({params}: {params: {projectId: string}}) {\r\n    const projectId = params.projectId;\r\n    const recordMap = await notion.getPage(projectId);\r\n    console.log(recordMap);\r\n    if (!recordMap) {\r\n        return <div>Loading...</div>;\r\n    }\r\n\r\n\r\n    return (\r\n        <div>\r\n            <Link href=\"/projects\">← Back to Projects</Link>\r\n            <ProjectView recordMap={recordMap} />\r\n        </div>\r\n    );\r\n}\r\n","import EventEmitter from './index.js'\n\nexport { EventEmitter }\nexport default EventEmitter\n","export class TimeoutError extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = 'TimeoutError';\n\t}\n}\n\n/**\nAn error to be thrown when the request is aborted by AbortController.\nDOMException is thrown instead of this Error when DOMException is available.\n*/\nexport class AbortError extends Error {\n\tconstructor(message) {\n\t\tsuper();\n\t\tthis.name = 'AbortError';\n\t\tthis.message = message;\n\t}\n}\n\n/**\nTODO: Remove AbortError and just throw DOMException when targeting Node 18.\n*/\nconst getDOMException = errorMessage => globalThis.DOMException === undefined\n\t? new AbortError(errorMessage)\n\t: new DOMException(errorMessage);\n\n/**\nTODO: Remove below function and just 'reject(signal.reason)' when targeting Node 18.\n*/\nconst getAbortedReason = signal => {\n\tconst reason = signal.reason === undefined\n\t\t? getDOMException('This operation was aborted.')\n\t\t: signal.reason;\n\n\treturn reason instanceof Error ? reason : getDOMException(reason);\n};\n\nexport default function pTimeout(promise, options) {\n\tconst {\n\t\tmilliseconds,\n\t\tfallback,\n\t\tmessage,\n\t\tcustomTimers = {setTimeout, clearTimeout},\n\t} = options;\n\n\tlet timer;\n\tlet abortHandler;\n\n\tconst wrappedPromise = new Promise((resolve, reject) => {\n\t\tif (typeof milliseconds !== 'number' || Math.sign(milliseconds) !== 1) {\n\t\t\tthrow new TypeError(`Expected \\`milliseconds\\` to be a positive number, got \\`${milliseconds}\\``);\n\t\t}\n\n\t\tif (options.signal) {\n\t\t\tconst {signal} = options;\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t}\n\n\t\t\tabortHandler = () => {\n\t\t\t\treject(getAbortedReason(signal));\n\t\t\t};\n\n\t\t\tsignal.addEventListener('abort', abortHandler, {once: true});\n\t\t}\n\n\t\tif (milliseconds === Number.POSITIVE_INFINITY) {\n\t\t\tpromise.then(resolve, reject);\n\t\t\treturn;\n\t\t}\n\n\t\t// We create the error outside of `setTimeout` to preserve the stack trace.\n\t\tconst timeoutError = new TimeoutError();\n\n\t\ttimer = customTimers.setTimeout.call(undefined, () => {\n\t\t\tif (fallback) {\n\t\t\t\ttry {\n\t\t\t\t\tresolve(fallback());\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tif (typeof promise.cancel === 'function') {\n\t\t\t\tpromise.cancel();\n\t\t\t}\n\n\t\t\tif (message === false) {\n\t\t\t\tresolve();\n\t\t\t} else if (message instanceof Error) {\n\t\t\t\treject(message);\n\t\t\t} else {\n\t\t\t\ttimeoutError.message = message ?? `Promise timed out after ${milliseconds} milliseconds`;\n\t\t\t\treject(timeoutError);\n\t\t\t}\n\t\t}, milliseconds);\n\n\t\t(async () => {\n\t\t\ttry {\n\t\t\t\tresolve(await promise);\n\t\t\t} catch (error) {\n\t\t\t\treject(error);\n\t\t\t}\n\t\t})();\n\t});\n\n\tconst cancelablePromise = wrappedPromise.finally(() => {\n\t\tcancelablePromise.clear();\n\t\tif (abortHandler && options.signal) {\n\t\t\toptions.signal.removeEventListener('abort', abortHandler);\n\t\t}\n\t});\n\n\tcancelablePromise.clear = () => {\n\t\tcustomTimers.clearTimeout.call(undefined, timer);\n\t\ttimer = undefined;\n\t};\n\n\treturn cancelablePromise;\n}\n","export default function isUrl(string, {lenient = false} = {}) {\n\tif (typeof string !== 'string') {\n\t\tthrow new TypeError('Expected a string');\n\t}\n\n\tstring = string.trim();\n\tif (string.includes(' ')) {\n\t\treturn false;\n\t}\n\n\ttry {\n\t\tnew URL(string); // eslint-disable-line no-new\n\t\treturn true;\n\t} catch {\n\t\tif (lenient) {\n\t\t\treturn isUrl(`https://${string}`);\n\t\t}\n\n\t\treturn false;\n\t}\n}\n","export default async function pMap(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tstopOnError = true,\n\t\tsignal,\n\t} = {},\n) {\n\treturn new Promise((resolve_, reject_) => {\n\t\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t\t}\n\n\t\tif (typeof mapper !== 'function') {\n\t\t\tthrow new TypeError('Mapper function is required');\n\t\t}\n\n\t\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t\t}\n\n\t\tconst result = [];\n\t\tconst errors = [];\n\t\tconst skippedIndexesMap = new Map();\n\t\tlet isRejected = false;\n\t\tlet isResolved = false;\n\t\tlet isIterableDone = false;\n\t\tlet resolvingCount = 0;\n\t\tlet currentIndex = 0;\n\t\tconst iterator = iterable[Symbol.iterator] === undefined ? iterable[Symbol.asyncIterator]() : iterable[Symbol.iterator]();\n\n\t\tconst signalListener = () => {\n\t\t\treject(signal.reason);\n\t\t};\n\n\t\tconst cleanup = () => {\n\t\t\tsignal?.removeEventListener('abort', signalListener);\n\t\t};\n\n\t\tconst resolve = value => {\n\t\t\tresolve_(value);\n\t\t\tcleanup();\n\t\t};\n\n\t\tconst reject = reason => {\n\t\t\tisRejected = true;\n\t\t\tisResolved = true;\n\t\t\treject_(reason);\n\t\t\tcleanup();\n\t\t};\n\n\t\tif (signal) {\n\t\t\tif (signal.aborted) {\n\t\t\t\treject(signal.reason);\n\t\t\t}\n\n\t\t\tsignal.addEventListener('abort', signalListener, {once: true});\n\t\t}\n\n\t\tconst next = async () => {\n\t\t\tif (isResolved) {\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tconst nextItem = await iterator.next();\n\n\t\t\tconst index = currentIndex;\n\t\t\tcurrentIndex++;\n\n\t\t\t// Note: `iterator.next()` can be called many times in parallel.\n\t\t\t// This can cause multiple calls to this `next()` function to\n\t\t\t// receive a `nextItem` with `done === true`.\n\t\t\t// The shutdown logic that rejects/resolves must be protected\n\t\t\t// so it runs only one time as the `skippedIndex` logic is\n\t\t\t// non-idempotent.\n\t\t\tif (nextItem.done) {\n\t\t\t\tisIterableDone = true;\n\n\t\t\t\tif (resolvingCount === 0 && !isResolved) {\n\t\t\t\t\tif (!stopOnError && errors.length > 0) {\n\t\t\t\t\t\treject(new AggregateError(errors)); // eslint-disable-line unicorn/error-message\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tisResolved = true;\n\n\t\t\t\t\tif (skippedIndexesMap.size === 0) {\n\t\t\t\t\t\tresolve(result);\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst pureResult = [];\n\n\t\t\t\t\t// Support multiple `pMapSkip`'s.\n\t\t\t\t\tfor (const [index, value] of result.entries()) {\n\t\t\t\t\t\tif (skippedIndexesMap.get(index) === pMapSkip) {\n\t\t\t\t\t\t\tcontinue;\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\tpureResult.push(value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresolve(pureResult);\n\t\t\t\t}\n\n\t\t\t\treturn;\n\t\t\t}\n\n\t\t\tresolvingCount++;\n\n\t\t\t// Intentionally detached\n\t\t\t(async () => {\n\t\t\t\ttry {\n\t\t\t\t\tconst element = await nextItem.value;\n\n\t\t\t\t\tif (isResolved) {\n\t\t\t\t\t\treturn;\n\t\t\t\t\t}\n\n\t\t\t\t\tconst value = await mapper(element, index);\n\n\t\t\t\t\t// Use Map to stage the index of the element.\n\t\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\t\tskippedIndexesMap.set(index, value);\n\t\t\t\t\t}\n\n\t\t\t\t\tresult[index] = value;\n\n\t\t\t\t\tresolvingCount--;\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\tif (stopOnError) {\n\t\t\t\t\t\treject(error);\n\t\t\t\t\t} else {\n\t\t\t\t\t\terrors.push(error);\n\t\t\t\t\t\tresolvingCount--;\n\n\t\t\t\t\t\t// In that case we can't really continue regardless of `stopOnError` state\n\t\t\t\t\t\t// since an iterable is likely to continue throwing after it throws once.\n\t\t\t\t\t\t// If we continue calling `next()` indefinitely we will likely end up\n\t\t\t\t\t\t// in an infinite loop of failed iteration.\n\t\t\t\t\t\ttry {\n\t\t\t\t\t\t\tawait next();\n\t\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\t\treject(error);\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t})();\n\t\t};\n\n\t\t// Create the concurrent runners in a detached (non-awaited)\n\t\t// promise. We need this so we can await the `next()` calls\n\t\t// to stop creating runners before hitting the concurrency limit\n\t\t// if the iterable has already been marked as done.\n\t\t// NOTE: We *must* do this for async iterators otherwise we'll spin up\n\t\t// infinite `next()` calls by default and never start the event loop.\n\t\t(async () => {\n\t\t\tfor (let index = 0; index < concurrency; index++) {\n\t\t\t\ttry {\n\t\t\t\t\t// eslint-disable-next-line no-await-in-loop\n\t\t\t\t\tawait next();\n\t\t\t\t} catch (error) {\n\t\t\t\t\treject(error);\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\n\t\t\t\tif (isIterableDone || isRejected) {\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t})();\n\t});\n}\n\nexport function pMapIterable(\n\titerable,\n\tmapper,\n\t{\n\t\tconcurrency = Number.POSITIVE_INFINITY,\n\t\tbackpressure = concurrency,\n\t} = {},\n) {\n\tif (iterable[Symbol.iterator] === undefined && iterable[Symbol.asyncIterator] === undefined) {\n\t\tthrow new TypeError(`Expected \\`input\\` to be either an \\`Iterable\\` or \\`AsyncIterable\\`, got (${typeof iterable})`);\n\t}\n\n\tif (typeof mapper !== 'function') {\n\t\tthrow new TypeError('Mapper function is required');\n\t}\n\n\tif (!((Number.isSafeInteger(concurrency) && concurrency >= 1) || concurrency === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`concurrency\\` to be an integer from 1 and up or \\`Infinity\\`, got \\`${concurrency}\\` (${typeof concurrency})`);\n\t}\n\n\tif (!((Number.isSafeInteger(backpressure) && backpressure >= concurrency) || backpressure === Number.POSITIVE_INFINITY)) {\n\t\tthrow new TypeError(`Expected \\`backpressure\\` to be an integer from \\`concurrency\\` (${concurrency}) and up or \\`Infinity\\`, got \\`${backpressure}\\` (${typeof backpressure})`);\n\t}\n\n\treturn {\n\t\tasync * [Symbol.asyncIterator]() {\n\t\t\tconst iterator = iterable[Symbol.asyncIterator] === undefined ? iterable[Symbol.iterator]() : iterable[Symbol.asyncIterator]();\n\n\t\t\tconst promises = [];\n\t\t\tlet runningMappersCount = 0;\n\t\t\tlet isDone = false;\n\t\t\tlet index = 0;\n\n\t\t\tfunction trySpawn() {\n\t\t\t\tif (isDone || !(runningMappersCount < concurrency && promises.length < backpressure)) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\tconst promise = (async () => {\n\t\t\t\t\tconst {done, value} = await iterator.next();\n\n\t\t\t\t\tif (done) {\n\t\t\t\t\t\treturn {done: true};\n\t\t\t\t\t}\n\n\t\t\t\t\trunningMappersCount++;\n\n\t\t\t\t\t// Spawn if still below concurrency and backpressure limit\n\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\ttry {\n\t\t\t\t\t\tconst returnValue = await mapper(await value, index++);\n\n\t\t\t\t\t\trunningMappersCount--;\n\n\t\t\t\t\t\tif (returnValue === pMapSkip) {\n\t\t\t\t\t\t\tconst index = promises.indexOf(promise);\n\n\t\t\t\t\t\t\tif (index > 0) {\n\t\t\t\t\t\t\t\tpromises.splice(index, 1);\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\n\t\t\t\t\t\t// Spawn if still below backpressure limit and just dropped below concurrency limit\n\t\t\t\t\t\ttrySpawn();\n\n\t\t\t\t\t\treturn {done: false, value: returnValue};\n\t\t\t\t\t} catch (error) {\n\t\t\t\t\t\tisDone = true;\n\t\t\t\t\t\treturn {error};\n\t\t\t\t\t}\n\t\t\t\t})();\n\n\t\t\t\tpromises.push(promise);\n\t\t\t}\n\n\t\t\ttrySpawn();\n\n\t\t\twhile (promises.length > 0) {\n\t\t\t\tconst {error, done, value} = await promises[0]; // eslint-disable-line no-await-in-loop\n\n\t\t\t\tpromises.shift();\n\n\t\t\t\tif (error) {\n\t\t\t\t\tthrow error;\n\t\t\t\t}\n\n\t\t\t\tif (done) {\n\t\t\t\t\treturn;\n\t\t\t\t}\n\n\t\t\t\t// Spawn if just dropped below backpressure limit and below the concurrency limit\n\t\t\t\ttrySpawn();\n\n\t\t\t\tif (value === pMapSkip) {\n\t\t\t\t\tcontinue;\n\t\t\t\t}\n\n\t\t\t\tyield value;\n\t\t\t}\n\t\t},\n\t};\n}\n\nexport const pMapSkip = Symbol('skip');\n","import mimicFunction from 'mimic-function';\nconst cacheStore = new WeakMap();\nconst cacheTimerStore = new WeakMap();\n/**\n[Memoize](https://en.wikipedia.org/wiki/Memoization) functions - An optimization used to speed up consecutive function calls by caching the result of calls with identical input.\n\n@param function_ - The function to be memoized.\n\n@example\n```\nimport memoize from 'memoize';\n\nlet index = 0;\nconst counter = () => ++index;\nconst memoized = memoize(counter);\n\nmemoized('foo');\n//=> 1\n\n// Cached as it's the same argument\nmemoized('foo');\n//=> 1\n\n// Not cached anymore as the arguments changed\nmemoized('bar');\n//=> 2\n\nmemoized('bar');\n//=> 2\n```\n*/\nexport default function memoize(function_, { cacheKey, cache = new Map(), maxAge, } = {}) {\n    if (maxAge === 0) {\n        return function_;\n    }\n    if (typeof maxAge === 'number') {\n        const maxSetIntervalValue = 2_147_483_647;\n        if (maxAge > maxSetIntervalValue) {\n            throw new TypeError(`The \\`maxAge\\` option cannot exceed ${maxSetIntervalValue}.`);\n        }\n        if (maxAge < 0) {\n            throw new TypeError('The `maxAge` option should not be a negative number.');\n        }\n    }\n    const memoized = function (...arguments_) {\n        const key = cacheKey ? cacheKey(arguments_) : arguments_[0];\n        const cacheItem = cache.get(key);\n        if (cacheItem) {\n            return cacheItem.data;\n        }\n        const result = function_.apply(this, arguments_);\n        const computedMaxAge = typeof maxAge === 'function' ? maxAge(...arguments_) : maxAge;\n        cache.set(key, {\n            data: result,\n            maxAge: computedMaxAge ? Date.now() + computedMaxAge : Number.POSITIVE_INFINITY,\n        });\n        if (computedMaxAge && computedMaxAge > 0 && computedMaxAge !== Number.POSITIVE_INFINITY) {\n            const timer = setTimeout(() => {\n                cache.delete(key);\n            }, computedMaxAge);\n            timer.unref?.();\n            const timers = cacheTimerStore.get(function_) ?? new Set();\n            timers.add(timer);\n            cacheTimerStore.set(function_, timers);\n        }\n        return result;\n    };\n    mimicFunction(memoized, function_, {\n        ignoreNonConfigurable: true,\n    });\n    cacheStore.set(memoized, cache);\n    return memoized;\n}\n/**\n@returns A [decorator](https://github.com/tc39/proposal-decorators) to memoize class methods or static class methods.\n\n@example\n```\nimport {memoizeDecorator} from 'memoize';\n\nclass Example {\n    index = 0\n\n    @memoizeDecorator()\n    counter() {\n        return ++this.index;\n    }\n}\n\nclass ExampleWithOptions {\n    index = 0\n\n    @memoizeDecorator({maxAge: 1000})\n    counter() {\n        return ++this.index;\n    }\n}\n```\n*/\nexport function memoizeDecorator(options = {}) {\n    const instanceMap = new WeakMap();\n    return (target, propertyKey, descriptor) => {\n        const input = target[propertyKey]; // eslint-disable-line @typescript-eslint/no-unsafe-assignment\n        if (typeof input !== 'function') {\n            throw new TypeError('The decorated value must be a function');\n        }\n        delete descriptor.value;\n        delete descriptor.writable;\n        descriptor.get = function () {\n            if (!instanceMap.has(this)) {\n                const value = memoize(input, options);\n                instanceMap.set(this, value);\n                return value;\n            }\n            return instanceMap.get(this);\n        };\n    };\n}\n/**\nClear all cached data of a memoized function.\n\n@param function_ - The memoized function.\n*/\nexport function memoizeClear(function_) {\n    const cache = cacheStore.get(function_);\n    if (!cache) {\n        throw new TypeError('Can\\'t clear a function that was not memoized!');\n    }\n    if (typeof cache.clear !== 'function') {\n        throw new TypeError('The cache Map can\\'t be cleared!');\n    }\n    cache.clear();\n    for (const timer of cacheTimerStore.get(function_) ?? []) {\n        clearTimeout(timer);\n    }\n}\n","import lowerBound from './lower-bound.js';\nexport default class PriorityQueue {\n    #queue = [];\n    enqueue(run, options) {\n        options = {\n            priority: 0,\n            ...options,\n        };\n        const element = {\n            priority: options.priority,\n            id: options.id,\n            run,\n        };\n        if (this.size === 0 || this.#queue[this.size - 1].priority >= options.priority) {\n            this.#queue.push(element);\n            return;\n        }\n        const index = lowerBound(this.#queue, element, (a, b) => b.priority - a.priority);\n        this.#queue.splice(index, 0, element);\n    }\n    setPriority(id, priority) {\n        const index = this.#queue.findIndex((element) => element.id === id);\n        if (index === -1) {\n            throw new ReferenceError(`No promise function with the id \"${id}\" exists in the queue.`);\n        }\n        const [item] = this.#queue.splice(index, 1);\n        this.enqueue(item.run, { priority, id });\n    }\n    dequeue() {\n        const item = this.#queue.shift();\n        return item?.run;\n    }\n    filter(options) {\n        return this.#queue.filter((element) => element.priority === options.priority).map((element) => element.run);\n    }\n    get size() {\n        return this.#queue.length;\n    }\n}\n","// Port of lower_bound from https://en.cppreference.com/w/cpp/algorithm/lower_bound\n// Used to compute insertion index to keep queue sorted after insertion\nexport default function lowerBound(array, value, comparator) {\n    let first = 0;\n    let count = array.length;\n    while (count > 0) {\n        const step = Math.trunc(count / 2);\n        let it = first + step;\n        if (comparator(array[it], value) <= 0) {\n            first = ++it;\n            count -= step + 1;\n        }\n        else {\n            count = step;\n        }\n    }\n    return first;\n}\n","import destr from 'destr';\nimport { withBase, withQuery } from 'ufo';\n\nclass FetchError extends Error {\n  constructor(message, opts) {\n    super(message, opts);\n    this.name = \"FetchError\";\n    if (opts?.cause && !this.cause) {\n      this.cause = opts.cause;\n    }\n  }\n}\nfunction createFetchError(ctx) {\n  const errorMessage = ctx.error?.message || ctx.error?.toString() || \"\";\n  const method = ctx.request?.method || ctx.options?.method || \"GET\";\n  const url = ctx.request?.url || String(ctx.request) || \"/\";\n  const requestStr = `[${method}] ${JSON.stringify(url)}`;\n  const statusStr = ctx.response ? `${ctx.response.status} ${ctx.response.statusText}` : \"<no response>\";\n  const message = `${requestStr}: ${statusStr}${errorMessage ? ` ${errorMessage}` : \"\"}`;\n  const fetchError = new FetchError(\n    message,\n    ctx.error ? { cause: ctx.error } : void 0\n  );\n  for (const key of [\"request\", \"options\", \"response\"]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx[key];\n      }\n    });\n  }\n  for (const [key, refKey] of [\n    [\"data\", \"_data\"],\n    [\"status\", \"status\"],\n    [\"statusCode\", \"status\"],\n    [\"statusText\", \"statusText\"],\n    [\"statusMessage\", \"statusText\"]\n  ]) {\n    Object.defineProperty(fetchError, key, {\n      get() {\n        return ctx.response && ctx.response[refKey];\n      }\n    });\n  }\n  return fetchError;\n}\n\nconst payloadMethods = new Set(\n  Object.freeze([\"PATCH\", \"POST\", \"PUT\", \"DELETE\"])\n);\nfunction isPayloadMethod(method = \"GET\") {\n  return payloadMethods.has(method.toUpperCase());\n}\nfunction isJSONSerializable(value) {\n  if (value === void 0) {\n    return false;\n  }\n  const t = typeof value;\n  if (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) {\n    return true;\n  }\n  if (t !== \"object\") {\n    return false;\n  }\n  if (Array.isArray(value)) {\n    return true;\n  }\n  if (value.buffer) {\n    return false;\n  }\n  return value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nconst textTypes = /* @__PURE__ */ new Set([\n  \"image/svg\",\n  \"application/xml\",\n  \"application/xhtml\",\n  \"application/html\"\n]);\nconst JSON_RE = /^application\\/(?:[\\w!#$%&*.^`~-]*\\+)?json(;.+)?$/i;\nfunction detectResponseType(_contentType = \"\") {\n  if (!_contentType) {\n    return \"json\";\n  }\n  const contentType = _contentType.split(\";\").shift() || \"\";\n  if (JSON_RE.test(contentType)) {\n    return \"json\";\n  }\n  if (textTypes.has(contentType) || contentType.startsWith(\"text/\")) {\n    return \"text\";\n  }\n  return \"blob\";\n}\nfunction resolveFetchOptions(request, input, defaults, Headers) {\n  const headers = mergeHeaders(\n    input?.headers ?? request?.headers,\n    defaults?.headers,\n    Headers\n  );\n  let query;\n  if (defaults?.query || defaults?.params || input?.params || input?.query) {\n    query = {\n      ...defaults?.params,\n      ...defaults?.query,\n      ...input?.params,\n      ...input?.query\n    };\n  }\n  return {\n    ...defaults,\n    ...input,\n    query,\n    params: query,\n    headers\n  };\n}\nfunction mergeHeaders(input, defaults, Headers) {\n  if (!defaults) {\n    return new Headers(input);\n  }\n  const headers = new Headers(defaults);\n  if (input) {\n    for (const [key, value] of Symbol.iterator in input || Array.isArray(input) ? input : new Headers(input)) {\n      headers.set(key, value);\n    }\n  }\n  return headers;\n}\nasync function callHooks(context, hooks) {\n  if (hooks) {\n    if (Array.isArray(hooks)) {\n      for (const hook of hooks) {\n        await hook(context);\n      }\n    } else {\n      await hooks(context);\n    }\n  }\n}\n\nconst retryStatusCodes = /* @__PURE__ */ new Set([\n  408,\n  // Request Timeout\n  409,\n  // Conflict\n  425,\n  // Too Early (Experimental)\n  429,\n  // Too Many Requests\n  500,\n  // Internal Server Error\n  502,\n  // Bad Gateway\n  503,\n  // Service Unavailable\n  504\n  // Gateway Timeout\n]);\nconst nullBodyResponses = /* @__PURE__ */ new Set([101, 204, 205, 304]);\nfunction createFetch(globalOptions = {}) {\n  const {\n    fetch = globalThis.fetch,\n    Headers = globalThis.Headers,\n    AbortController = globalThis.AbortController\n  } = globalOptions;\n  async function onError(context) {\n    const isAbort = context.error && context.error.name === \"AbortError\" && !context.options.timeout || false;\n    if (context.options.retry !== false && !isAbort) {\n      let retries;\n      if (typeof context.options.retry === \"number\") {\n        retries = context.options.retry;\n      } else {\n        retries = isPayloadMethod(context.options.method) ? 0 : 1;\n      }\n      const responseCode = context.response && context.response.status || 500;\n      if (retries > 0 && (Array.isArray(context.options.retryStatusCodes) ? context.options.retryStatusCodes.includes(responseCode) : retryStatusCodes.has(responseCode))) {\n        const retryDelay = typeof context.options.retryDelay === \"function\" ? context.options.retryDelay(context) : context.options.retryDelay || 0;\n        if (retryDelay > 0) {\n          await new Promise((resolve) => setTimeout(resolve, retryDelay));\n        }\n        return $fetchRaw(context.request, {\n          ...context.options,\n          retry: retries - 1\n        });\n      }\n    }\n    const error = createFetchError(context);\n    if (Error.captureStackTrace) {\n      Error.captureStackTrace(error, $fetchRaw);\n    }\n    throw error;\n  }\n  const $fetchRaw = async function $fetchRaw2(_request, _options = {}) {\n    const context = {\n      request: _request,\n      options: resolveFetchOptions(\n        _request,\n        _options,\n        globalOptions.defaults,\n        Headers\n      ),\n      response: void 0,\n      error: void 0\n    };\n    if (context.options.method) {\n      context.options.method = context.options.method.toUpperCase();\n    }\n    if (context.options.onRequest) {\n      await callHooks(context, context.options.onRequest);\n    }\n    if (typeof context.request === \"string\") {\n      if (context.options.baseURL) {\n        context.request = withBase(context.request, context.options.baseURL);\n      }\n      if (context.options.query) {\n        context.request = withQuery(context.request, context.options.query);\n        delete context.options.query;\n      }\n      if (\"query\" in context.options) {\n        delete context.options.query;\n      }\n      if (\"params\" in context.options) {\n        delete context.options.params;\n      }\n    }\n    if (context.options.body && isPayloadMethod(context.options.method)) {\n      if (isJSONSerializable(context.options.body)) {\n        context.options.body = typeof context.options.body === \"string\" ? context.options.body : JSON.stringify(context.options.body);\n        context.options.headers = new Headers(context.options.headers || {});\n        if (!context.options.headers.has(\"content-type\")) {\n          context.options.headers.set(\"content-type\", \"application/json\");\n        }\n        if (!context.options.headers.has(\"accept\")) {\n          context.options.headers.set(\"accept\", \"application/json\");\n        }\n      } else if (\n        // ReadableStream Body\n        \"pipeTo\" in context.options.body && typeof context.options.body.pipeTo === \"function\" || // Node.js Stream Body\n        typeof context.options.body.pipe === \"function\"\n      ) {\n        if (!(\"duplex\" in context.options)) {\n          context.options.duplex = \"half\";\n        }\n      }\n    }\n    let abortTimeout;\n    if (!context.options.signal && context.options.timeout) {\n      const controller = new AbortController();\n      abortTimeout = setTimeout(() => {\n        const error = new Error(\n          \"[TimeoutError]: The operation was aborted due to timeout\"\n        );\n        error.name = \"TimeoutError\";\n        error.code = 23;\n        controller.abort(error);\n      }, context.options.timeout);\n      context.options.signal = controller.signal;\n    }\n    try {\n      context.response = await fetch(\n        context.request,\n        context.options\n      );\n    } catch (error) {\n      context.error = error;\n      if (context.options.onRequestError) {\n        await callHooks(\n          context,\n          context.options.onRequestError\n        );\n      }\n      return await onError(context);\n    } finally {\n      if (abortTimeout) {\n        clearTimeout(abortTimeout);\n      }\n    }\n    const hasBody = (context.response.body || // https://github.com/unjs/ofetch/issues/324\n    // https://github.com/unjs/ofetch/issues/294\n    // https://github.com/JakeChampion/fetch/issues/1454\n    context.response._bodyInit) && !nullBodyResponses.has(context.response.status) && context.options.method !== \"HEAD\";\n    if (hasBody) {\n      const responseType = (context.options.parseResponse ? \"json\" : context.options.responseType) || detectResponseType(context.response.headers.get(\"content-type\") || \"\");\n      switch (responseType) {\n        case \"json\": {\n          const data = await context.response.text();\n          const parseFunction = context.options.parseResponse || destr;\n          context.response._data = parseFunction(data);\n          break;\n        }\n        case \"stream\": {\n          context.response._data = context.response.body || context.response._bodyInit;\n          break;\n        }\n        default: {\n          context.response._data = await context.response[responseType]();\n        }\n      }\n    }\n    if (context.options.onResponse) {\n      await callHooks(\n        context,\n        context.options.onResponse\n      );\n    }\n    if (!context.options.ignoreResponseError && context.response.status >= 400 && context.response.status < 600) {\n      if (context.options.onResponseError) {\n        await callHooks(\n          context,\n          context.options.onResponseError\n        );\n      }\n      return await onError(context);\n    }\n    return context.response;\n  };\n  const $fetch = async function $fetch2(request, options) {\n    const r = await $fetchRaw(request, options);\n    return r._data;\n  };\n  $fetch.raw = $fetchRaw;\n  $fetch.native = (...args) => fetch(...args);\n  $fetch.create = (defaultOptions = {}, customGlobalOptions = {}) => createFetch({\n    ...globalOptions,\n    ...customGlobalOptions,\n    defaults: {\n      ...globalOptions.defaults,\n      ...customGlobalOptions.defaults,\n      ...defaultOptions\n    }\n  });\n  return $fetch;\n}\n\nexport { FetchError as F, createFetchError as a, createFetch as c };\n","import { EventEmitter } from 'eventemitter3';\nimport pTimeout, { TimeoutError } from 'p-timeout';\nimport PriorityQueue from './priority-queue.js';\n/**\nPromise queue with concurrency control.\n*/\nexport default class PQueue extends EventEmitter {\n    #carryoverConcurrencyCount;\n    #isIntervalIgnored;\n    #intervalCount = 0;\n    #intervalCap;\n    #interval;\n    #intervalEnd = 0;\n    #intervalId;\n    #timeoutId;\n    #queue;\n    #queueClass;\n    #pending = 0;\n    // The `!` is needed because of https://github.com/microsoft/TypeScript/issues/32194\n    #concurrency;\n    #isPaused;\n    #throwOnTimeout;\n    // Use to assign a unique identifier to a promise function, if not explicitly specified\n    #idAssigner = 1n;\n    /**\n    Per-operation timeout in milliseconds. Operations fulfill once `timeout` elapses if they haven't already.\n\n    Applies to each future operation.\n    */\n    timeout;\n    // TODO: The `throwOnTimeout` option should affect the return types of `add()` and `addAll()`\n    constructor(options) {\n        super();\n        // eslint-disable-next-line @typescript-eslint/consistent-type-assertions\n        options = {\n            carryoverConcurrencyCount: false,\n            intervalCap: Number.POSITIVE_INFINITY,\n            interval: 0,\n            concurrency: Number.POSITIVE_INFINITY,\n            autoStart: true,\n            queueClass: PriorityQueue,\n            ...options,\n        };\n        if (!(typeof options.intervalCap === 'number' && options.intervalCap >= 1)) {\n            throw new TypeError(`Expected \\`intervalCap\\` to be a number from 1 and up, got \\`${options.intervalCap?.toString() ?? ''}\\` (${typeof options.intervalCap})`);\n        }\n        if (options.interval === undefined || !(Number.isFinite(options.interval) && options.interval >= 0)) {\n            throw new TypeError(`Expected \\`interval\\` to be a finite number >= 0, got \\`${options.interval?.toString() ?? ''}\\` (${typeof options.interval})`);\n        }\n        this.#carryoverConcurrencyCount = options.carryoverConcurrencyCount;\n        this.#isIntervalIgnored = options.intervalCap === Number.POSITIVE_INFINITY || options.interval === 0;\n        this.#intervalCap = options.intervalCap;\n        this.#interval = options.interval;\n        this.#queue = new options.queueClass();\n        this.#queueClass = options.queueClass;\n        this.concurrency = options.concurrency;\n        this.timeout = options.timeout;\n        this.#throwOnTimeout = options.throwOnTimeout === true;\n        this.#isPaused = options.autoStart === false;\n    }\n    get #doesIntervalAllowAnother() {\n        return this.#isIntervalIgnored || this.#intervalCount < this.#intervalCap;\n    }\n    get #doesConcurrentAllowAnother() {\n        return this.#pending < this.#concurrency;\n    }\n    #next() {\n        this.#pending--;\n        this.#tryToStartAnother();\n        this.emit('next');\n    }\n    #onResumeInterval() {\n        this.#onInterval();\n        this.#initializeIntervalIfNeeded();\n        this.#timeoutId = undefined;\n    }\n    get #isIntervalPaused() {\n        const now = Date.now();\n        if (this.#intervalId === undefined) {\n            const delay = this.#intervalEnd - now;\n            if (delay < 0) {\n                // Act as the interval was done\n                // We don't need to resume it here because it will be resumed on line 160\n                this.#intervalCount = (this.#carryoverConcurrencyCount) ? this.#pending : 0;\n            }\n            else {\n                // Act as the interval is pending\n                if (this.#timeoutId === undefined) {\n                    this.#timeoutId = setTimeout(() => {\n                        this.#onResumeInterval();\n                    }, delay);\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #tryToStartAnother() {\n        if (this.#queue.size === 0) {\n            // We can clear the interval (\"pause\")\n            // Because we can redo it later (\"resume\")\n            if (this.#intervalId) {\n                clearInterval(this.#intervalId);\n            }\n            this.#intervalId = undefined;\n            this.emit('empty');\n            if (this.#pending === 0) {\n                this.emit('idle');\n            }\n            return false;\n        }\n        if (!this.#isPaused) {\n            const canInitializeInterval = !this.#isIntervalPaused;\n            if (this.#doesIntervalAllowAnother && this.#doesConcurrentAllowAnother) {\n                const job = this.#queue.dequeue();\n                if (!job) {\n                    return false;\n                }\n                this.emit('active');\n                job();\n                if (canInitializeInterval) {\n                    this.#initializeIntervalIfNeeded();\n                }\n                return true;\n            }\n        }\n        return false;\n    }\n    #initializeIntervalIfNeeded() {\n        if (this.#isIntervalIgnored || this.#intervalId !== undefined) {\n            return;\n        }\n        this.#intervalId = setInterval(() => {\n            this.#onInterval();\n        }, this.#interval);\n        this.#intervalEnd = Date.now() + this.#interval;\n    }\n    #onInterval() {\n        if (this.#intervalCount === 0 && this.#pending === 0 && this.#intervalId) {\n            clearInterval(this.#intervalId);\n            this.#intervalId = undefined;\n        }\n        this.#intervalCount = this.#carryoverConcurrencyCount ? this.#pending : 0;\n        this.#processQueue();\n    }\n    /**\n    Executes all queued functions until it reaches the limit.\n    */\n    #processQueue() {\n        // eslint-disable-next-line no-empty\n        while (this.#tryToStartAnother()) { }\n    }\n    get concurrency() {\n        return this.#concurrency;\n    }\n    set concurrency(newConcurrency) {\n        if (!(typeof newConcurrency === 'number' && newConcurrency >= 1)) {\n            throw new TypeError(`Expected \\`concurrency\\` to be a number from 1 and up, got \\`${newConcurrency}\\` (${typeof newConcurrency})`);\n        }\n        this.#concurrency = newConcurrency;\n        this.#processQueue();\n    }\n    async #throwOnAbort(signal) {\n        return new Promise((_resolve, reject) => {\n            signal.addEventListener('abort', () => {\n                reject(signal.reason);\n            }, { once: true });\n        });\n    }\n    /**\n    Updates the priority of a promise function by its id, affecting its execution order. Requires a defined concurrency limit to take effect.\n\n    For example, this can be used to prioritize a promise function to run earlier.\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦀', {priority: 0, id: '🦀'});\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦄', {priority: 1});\n\n    queue.setPriority('🦀', 2);\n    ```\n\n    In this case, the promise function with `id: '🦀'` runs second.\n\n    You can also deprioritize a promise function to delay its execution:\n\n    ```js\n    import PQueue from 'p-queue';\n\n    const queue = new PQueue({concurrency: 1});\n\n    queue.add(async () => '🦄', {priority: 1});\n    queue.add(async () => '🦀', {priority: 1, id: '🦀'});\n    queue.add(async () => '🦄');\n    queue.add(async () => '🦄', {priority: 0});\n\n    queue.setPriority('🦀', -1);\n    ```\n    Here, the promise function with `id: '🦀'` executes last.\n    */\n    setPriority(id, priority) {\n        this.#queue.setPriority(id, priority);\n    }\n    async add(function_, options = {}) {\n        // In case `id` is not defined.\n        options.id ??= (this.#idAssigner++).toString();\n        options = {\n            timeout: this.timeout,\n            throwOnTimeout: this.#throwOnTimeout,\n            ...options,\n        };\n        return new Promise((resolve, reject) => {\n            this.#queue.enqueue(async () => {\n                this.#pending++;\n                try {\n                    options.signal?.throwIfAborted();\n                    this.#intervalCount++;\n                    let operation = function_({ signal: options.signal });\n                    if (options.timeout) {\n                        operation = pTimeout(Promise.resolve(operation), { milliseconds: options.timeout });\n                    }\n                    if (options.signal) {\n                        operation = Promise.race([operation, this.#throwOnAbort(options.signal)]);\n                    }\n                    const result = await operation;\n                    resolve(result);\n                    this.emit('completed', result);\n                }\n                catch (error) {\n                    if (error instanceof TimeoutError && !options.throwOnTimeout) {\n                        resolve();\n                        return;\n                    }\n                    reject(error);\n                    this.emit('error', error);\n                }\n                finally {\n                    this.#next();\n                }\n            }, options);\n            this.emit('add');\n            this.#tryToStartAnother();\n        });\n    }\n    async addAll(functions, options) {\n        return Promise.all(functions.map(async (function_) => this.add(function_, options)));\n    }\n    /**\n    Start (or resume) executing enqueued tasks within concurrency limit. No need to call this if queue is not paused (via `options.autoStart = false` or by `.pause()` method.)\n    */\n    start() {\n        if (!this.#isPaused) {\n            return this;\n        }\n        this.#isPaused = false;\n        this.#processQueue();\n        return this;\n    }\n    /**\n    Put queue execution on hold.\n    */\n    pause() {\n        this.#isPaused = true;\n    }\n    /**\n    Clear the queue.\n    */\n    clear() {\n        this.#queue = new this.#queueClass();\n    }\n    /**\n    Can be called multiple times. Useful if you for example add additional items at a later time.\n\n    @returns A promise that settles when the queue becomes empty.\n    */\n    async onEmpty() {\n        // Instantly resolve if the queue is empty\n        if (this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('empty');\n    }\n    /**\n    @returns A promise that settles when the queue size is less than the given limit: `queue.size < limit`.\n\n    If you want to avoid having the queue grow beyond a certain size you can `await queue.onSizeLessThan()` before adding a new item.\n\n    Note that this only limits the number of items waiting to start. There could still be up to `concurrency` jobs already running that this call does not include in its calculation.\n    */\n    async onSizeLessThan(limit) {\n        // Instantly resolve if the queue is empty.\n        if (this.#queue.size < limit) {\n            return;\n        }\n        await this.#onEvent('next', () => this.#queue.size < limit);\n    }\n    /**\n    The difference with `.onEmpty` is that `.onIdle` guarantees that all work from the queue has finished. `.onEmpty` merely signals that the queue is empty, but it could mean that some promises haven't completed yet.\n\n    @returns A promise that settles when the queue becomes empty, and all promises have completed; `queue.size === 0 && queue.pending === 0`.\n    */\n    async onIdle() {\n        // Instantly resolve if none pending and if nothing else is queued\n        if (this.#pending === 0 && this.#queue.size === 0) {\n            return;\n        }\n        await this.#onEvent('idle');\n    }\n    async #onEvent(event, filter) {\n        return new Promise(resolve => {\n            const listener = () => {\n                if (filter && !filter()) {\n                    return;\n                }\n                this.off(event, listener);\n                resolve();\n            };\n            this.on(event, listener);\n        });\n    }\n    /**\n    Size of the queue, the number of queued items waiting to run.\n    */\n    get size() {\n        return this.#queue.size;\n    }\n    /**\n    Size of the queue, filtered by the given options.\n\n    For example, this can be used to find the number of items remaining in the queue with a specific priority level.\n    */\n    sizeBy(options) {\n        // eslint-disable-next-line unicorn/no-array-callback-reference\n        return this.#queue.filter(options).length;\n    }\n    /**\n    Number of running items (no longer in the queue).\n    */\n    get pending() {\n        return this.#pending;\n    }\n    /**\n    Whether the queue is currently paused.\n    */\n    get isPaused() {\n        return this.#isPaused;\n    }\n}\n","// src/estimate-page-read-time.ts\nimport \"notion-types\";\n\n// src/get-block-title.ts\nimport \"notion-types\";\n\n// src/get-block-collection-id.ts\nimport \"notion-types\";\nfunction getBlockCollectionId(block, recordMap) {\n  var _a, _b, _c, _d, _e, _f, _g;\n  const collectionId = block.collection_id || ((_b = (_a = block.format) == null ? void 0 : _a.collection_pointer) == null ? void 0 : _b.id);\n  if (collectionId) {\n    return collectionId;\n  }\n  const collectionViewId = (_c = block == null ? void 0 : block.view_ids) == null ? void 0 : _c[0];\n  if (collectionViewId) {\n    const collectionView = (_e = (_d = recordMap.collection_view) == null ? void 0 : _d[collectionViewId]) == null ? void 0 : _e.value;\n    if (collectionView) {\n      const collectionId2 = (_g = (_f = collectionView.format) == null ? void 0 : _f.collection_pointer) == null ? void 0 : _g.id;\n      return collectionId2;\n    }\n  }\n  return null;\n}\n\n// src/get-text-content.ts\nvar getTextContent = (text) => {\n  var _a;\n  if (!text) {\n    return \"\";\n  } else if (Array.isArray(text)) {\n    return (_a = text == null ? void 0 : text.reduce(\n      (prev, current) => prev + (current[0] !== \"\\u204D\" && current[0] !== \"\\u2023\" ? current[0] : \"\"),\n      \"\"\n    )) != null ? _a : \"\";\n  } else {\n    return text;\n  }\n};\n\n// src/get-block-title.ts\nfunction getBlockTitle(block, recordMap) {\n  var _a, _b;\n  if ((_a = block.properties) == null ? void 0 : _a.title) {\n    return getTextContent(block.properties.title);\n  }\n  if (block.type === \"collection_view_page\" || block.type === \"collection_view\") {\n    const collectionId = getBlockCollectionId(block, recordMap);\n    if (collectionId) {\n      const collection = (_b = recordMap.collection[collectionId]) == null ? void 0 : _b.value;\n      if (collection) {\n        return getTextContent(collection.name);\n      }\n    }\n  }\n  return \"\";\n}\n\n// src/get-page-table-of-contents.ts\nvar indentLevels = {\n  header: 0,\n  sub_header: 1,\n  sub_sub_header: 2\n};\nvar getPageTableOfContents = (page, recordMap) => {\n  function mapContentToEntries(content) {\n    return (content != null ? content : []).map((blockId) => {\n      var _a, _b;\n      const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;\n      if (block) {\n        const { type } = block;\n        if (type === \"header\" || type === \"sub_header\" || type === \"sub_sub_header\") {\n          return {\n            id: blockId,\n            type,\n            text: getTextContent((_b = block.properties) == null ? void 0 : _b.title),\n            indentLevel: indentLevels[type]\n          };\n        }\n        if (type === \"transclusion_container\") {\n          return mapContentToEntries(block.content);\n        }\n      }\n      return null;\n    });\n  }\n  const toc = mapContentToEntries(page.content).flat().filter(Boolean);\n  const indentLevelStack = [\n    {\n      actual: -1,\n      effective: -1\n    }\n  ];\n  for (const tocItem of toc) {\n    const { indentLevel } = tocItem;\n    const actual = indentLevel;\n    do {\n      const prevIndent = indentLevelStack.at(-1);\n      const { actual: prevActual, effective: prevEffective } = prevIndent;\n      if (actual > prevActual) {\n        tocItem.indentLevel = prevEffective + 1;\n        indentLevelStack.push({\n          actual,\n          effective: tocItem.indentLevel\n        });\n      } else if (actual === prevActual) {\n        tocItem.indentLevel = prevEffective;\n        break;\n      } else {\n        indentLevelStack.pop();\n      }\n    } while (true);\n  }\n  return toc;\n};\n\n// src/estimate-page-read-time.ts\nfunction estimatePageReadTime(block, recordMap, {\n  wordsPerMinute = 275,\n  imageReadTimeInSeconds = 12\n} = {}) {\n  const stats = getBlockContentStats(block, recordMap);\n  const totalWordsReadTimeInMinutes = stats.numWords / wordsPerMinute;\n  const totalImageReadTimeInSeconds = stats.numImages > 10 ? stats.numImages / 2 * (imageReadTimeInSeconds + 3) + (stats.numImages - 10) * 3 : stats.numImages / 2 * (2 * imageReadTimeInSeconds + (1 - stats.numImages));\n  const totalImageReadTimeInMinutes = totalImageReadTimeInSeconds / 60;\n  const totalReadTimeInMinutes = totalWordsReadTimeInMinutes + totalImageReadTimeInMinutes;\n  return {\n    ...stats,\n    totalWordsReadTimeInMinutes,\n    totalImageReadTimeInMinutes,\n    totalReadTimeInMinutes\n  };\n}\nfunction estimatePageReadTimeAsHumanizedString(block, recordMap, opts) {\n  const estimate = estimatePageReadTime(block, recordMap, opts);\n  return humanizeReadTime(estimate.totalReadTimeInMinutes);\n}\nfunction getBlockContentStats(block, recordMap) {\n  var _a, _b, _c, _d;\n  const stats = {\n    numWords: 0,\n    numImages: 0\n  };\n  if (!block) {\n    return stats;\n  }\n  for (const childId of block.content || []) {\n    const child = (_a = recordMap.block[childId]) == null ? void 0 : _a.value;\n    let recurse = false;\n    if (!child) continue;\n    switch (child.type) {\n      case \"quote\":\n      // fallthrough\n      case \"alias\":\n      // fallthrough\n      case \"header\":\n      // fallthrough\n      case \"sub_header\":\n      // fallthrough\n      case \"sub_sub_header\": {\n        const title = getBlockTitle(child, recordMap);\n        stats.numWords += countWordsInText(title);\n        break;\n      }\n      case \"callout\":\n      // fallthrough\n      case \"toggle\":\n      // fallthrough\n      case \"to_do\":\n      // fallthrough\n      case \"bulleted_list\":\n      // fallthrough\n      case \"numbered_list\":\n      // fallthrough\n      case \"text\": {\n        const title = getBlockTitle(child, recordMap);\n        stats.numWords += countWordsInText(title);\n        recurse = true;\n        break;\n      }\n      case \"embed\":\n      // fallthrough\n      case \"tweet\":\n      // fallthrough\n      case \"maps\":\n      // fallthrough\n      case \"pdf\":\n      // fallthrough\n      case \"figma\":\n      // fallthrough\n      case \"typeform\":\n      // fallthrough\n      case \"codepen\":\n      // fallthrough\n      case \"excalidraw\":\n      // fallthrough\n      case \"gist\":\n      // fallthrough\n      case \"video\":\n      // fallthrough\n      case \"drive\":\n      // fallthrough\n      case \"audio\":\n      // fallthrough\n      case \"file\":\n      // fallthrough\n      case \"image\":\n        stats.numImages += 1;\n        break;\n      case \"bookmark\":\n        stats.numImages += 0.25;\n        break;\n      case \"code\":\n        stats.numImages += 2;\n        break;\n      case \"table\":\n      // fallthrough\n      case \"collection_view\":\n        stats.numImages += 2;\n        break;\n      case \"column\":\n      // fallthrough\n      case \"column_list\":\n      // fallthrough\n      case \"transclusion_container\":\n        recurse = true;\n        break;\n      case \"table_of_contents\": {\n        const page = block;\n        if (!page) continue;\n        const toc = getPageTableOfContents(page, recordMap);\n        for (const tocItem of toc) {\n          stats.numWords += countWordsInText(tocItem.text);\n        }\n        break;\n      }\n      case \"transclusion_reference\": {\n        const referencePointerId = (_c = (_b = child == null ? void 0 : child.format) == null ? void 0 : _b.transclusion_reference_pointer) == null ? void 0 : _c.id;\n        if (!referencePointerId) {\n          continue;\n        }\n        const referenceBlock = (_d = recordMap.block[referencePointerId]) == null ? void 0 : _d.value;\n        if (referenceBlock) {\n          mergeContentStats(\n            stats,\n            getBlockContentStats(referenceBlock, recordMap)\n          );\n        }\n        break;\n      }\n      default:\n        break;\n    }\n    if (recurse) {\n      mergeContentStats(stats, getBlockContentStats(child, recordMap));\n    }\n  }\n  return stats;\n}\nfunction mergeContentStats(statsA, statsB) {\n  statsA.numWords += statsB.numWords;\n  statsA.numImages += statsB.numImages;\n}\nfunction countWordsInText(text) {\n  if (!text) {\n    return 0;\n  }\n  return (text.match(/\\w+/g) || []).length;\n}\nfunction humanizeReadTime(time) {\n  if (time < 0.5) {\n    return \"less than a minute\";\n  }\n  if (time < 1.5) {\n    return \"1 minute\";\n  }\n  return `${Math.ceil(time)} minutes`;\n}\n\n// src/format-date.ts\nvar formatDate = (input, { month = \"short\" } = {}) => {\n  const date = new Date(input);\n  const monthLocale = date.toLocaleString(\"en-US\", { month });\n  return `${monthLocale} ${date.getUTCDate()}, ${date.getUTCFullYear()}`;\n};\n\n// src/format-notion-date-time.ts\nvar formatNotionDateTime = (datetime) => {\n  const dateString = `${datetime.start_date}T${datetime.start_time || \"00:00\"}+00:00`;\n  return formatDate(dateString);\n};\n\n// src/get-all-pages-in-space.ts\nimport \"notion-types\";\nimport PQueue from \"p-queue\";\n\n// src/id-to-uuid.ts\nvar idToUuid = (id = \"\") => `${id.slice(0, 8)}-${id.slice(8, 12)}-${id.slice(12, 16)}-${id.slice(\n  16,\n  20\n)}-${id.slice(20)}`;\n\n// src/parse-page-id.ts\nvar pageIdRe = /\\b([\\da-f]{32})\\b/;\nvar pageId2Re = /\\b([\\da-f]{8}(?:-[\\da-f]{4}){3}-[\\da-f]{12})\\b/;\nvar parsePageId = (id = \"\", { uuid = true } = {}) => {\n  if (!id) return;\n  id = id.split(\"?\")[0];\n  if (!id) return;\n  const match = id.match(pageIdRe);\n  if (match) {\n    return uuid ? idToUuid(match[1]) : match[1];\n  }\n  const match2 = id.match(pageId2Re);\n  if (match2) {\n    return uuid ? match2[1] : match2[1].replaceAll(\"-\", \"\");\n  }\n  return;\n};\n\n// src/get-all-pages-in-space.ts\nasync function getAllPagesInSpace(rootPageId, rootSpaceId, getPage, {\n  concurrency = 4,\n  traverseCollections = true,\n  targetPageId,\n  maxDepth = Number.POSITIVE_INFINITY\n} = {}) {\n  const pages = {};\n  const pendingPageIds = /* @__PURE__ */ new Set();\n  const queue = new PQueue({ concurrency });\n  async function processPage(pageId, depth = 0) {\n    if (depth > maxDepth) {\n      return;\n    }\n    if (targetPageId && pendingPageIds.has(targetPageId)) {\n      return;\n    }\n    pageId = parsePageId(pageId);\n    if (pageId && !pages[pageId] && !pendingPageIds.has(pageId)) {\n      pendingPageIds.add(pageId);\n      void queue.add(async () => {\n        var _a, _b, _c;\n        try {\n          if (targetPageId && pendingPageIds.has(targetPageId) && pageId !== targetPageId) {\n            return;\n          }\n          const page = await getPage(pageId);\n          if (!page) {\n            return;\n          }\n          const spaceId = (_b = (_a = page.block[pageId]) == null ? void 0 : _a.value) == null ? void 0 : _b.space_id;\n          if (spaceId) {\n            if (!rootSpaceId) {\n              rootSpaceId = spaceId;\n            } else if (rootSpaceId !== spaceId) {\n              return;\n            }\n          }\n          for (const subPageId of Object.keys(page.block).filter((key) => {\n            var _a2;\n            const block = (_a2 = page.block[key]) == null ? void 0 : _a2.value;\n            if (!block || block.alive === false) return false;\n            if (block.type !== \"page\" && block.type !== \"collection_view_page\") {\n              return false;\n            }\n            if (rootSpaceId && block.space_id && block.space_id !== rootSpaceId) {\n              return false;\n            }\n            return true;\n          })) {\n            void processPage(subPageId, depth + 1);\n          }\n          if (traverseCollections) {\n            for (const collectionViews of Object.values(\n              page.collection_query\n            )) {\n              for (const collectionData of Object.values(collectionViews)) {\n                const blockIds = Array.from(\n                  /* @__PURE__ */ new Set([\n                    ...((_c = collectionData == null ? void 0 : collectionData.collection_group_results) == null ? void 0 : _c.blockIds) || [],\n                    ...collectionData.blockIds || []\n                  ])\n                );\n                if (blockIds.length) {\n                  for (const collectionItemId of blockIds) {\n                    void processPage(collectionItemId, depth + 1);\n                  }\n                }\n              }\n            }\n          }\n          pages[pageId] = page;\n        } catch (err) {\n          console.warn(\n            \"page load error\",\n            { pageId, spaceId: rootSpaceId },\n            err.statusCode,\n            err.message\n          );\n          pages[pageId] = null;\n        }\n        pendingPageIds.delete(pageId);\n      });\n    }\n  }\n  await processPage(rootPageId);\n  await queue.onIdle();\n  return pages;\n}\n\n// src/get-block-icon.ts\nimport \"notion-types\";\nfunction getBlockIcon(block, recordMap) {\n  var _a, _b, _c;\n  if ((_a = block.format) == null ? void 0 : _a.page_icon) {\n    return (_b = block.format) == null ? void 0 : _b.page_icon;\n  }\n  if (block.type === \"collection_view_page\" || block.type === \"collection_view\") {\n    const collectionId = getBlockCollectionId(block, recordMap);\n    if (collectionId) {\n      const collection = (_c = recordMap.collection[collectionId]) == null ? void 0 : _c.value;\n      if (collection) {\n        return collection.icon;\n      }\n    }\n  }\n  return null;\n}\n\n// src/get-block-parent-page.ts\nvar getBlockParentPage = (block, recordMap, {\n  inclusive = false\n} = {}) => {\n  var _a, _b;\n  let currentRecord = block;\n  while (currentRecord) {\n    if (inclusive && (currentRecord == null ? void 0 : currentRecord.type) === \"page\") {\n      return currentRecord;\n    }\n    const parentId = currentRecord.parent_id;\n    const parentTable = currentRecord.parent_table;\n    if (!parentId) {\n      break;\n    }\n    if (parentTable === \"collection\") {\n      currentRecord = (_a = recordMap.collection[parentId]) == null ? void 0 : _a.value;\n    } else {\n      currentRecord = (_b = recordMap.block[parentId]) == null ? void 0 : _b.value;\n      if ((currentRecord == null ? void 0 : currentRecord.type) === \"page\") {\n        return currentRecord;\n      }\n    }\n  }\n  return null;\n};\n\n// src/get-canonical-page-id.ts\nimport \"notion-types\";\n\n// src/get-page-property.ts\nimport \"notion-types\";\nfunction getPageProperty(propertyName, block, recordMap) {\n  var _a;\n  try {\n    if (!block.properties || !Object.keys(recordMap.collection)) {\n      return null;\n    }\n    const collection = (_a = recordMap.collection[block.parent_id]) == null ? void 0 : _a.value;\n    if (collection) {\n      const propertyNameL = propertyName.toLowerCase();\n      const propertyId = Object.keys(collection.schema).find(\n        (key) => {\n          var _a2, _b;\n          return ((_b = (_a2 = collection.schema[key]) == null ? void 0 : _a2.name) == null ? void 0 : _b.toLowerCase()) === propertyNameL;\n        }\n      );\n      if (!propertyId) {\n        return null;\n      }\n      const s = collection.schema[propertyId];\n      if (!s) {\n        return null;\n      }\n      const { type } = s;\n      const content = getTextContent(block.properties[propertyId]);\n      switch (type) {\n        case \"created_time\":\n          return block.created_time;\n        case \"multi_select\":\n          return content.split(\",\");\n        case \"date\": {\n          const property = block.properties[propertyId];\n          const formatDate2 = property[0][1][0][1];\n          if (formatDate2.type === \"datetime\") {\n            return (/* @__PURE__ */ new Date(\n              `${formatDate2.start_date} ${formatDate2.start_time}`\n            )).getTime();\n          } else if (formatDate2.type === \"date\") {\n            return new Date(formatDate2.start_date).getTime();\n          } else if (formatDate2.type === \"datetimerange\") {\n            const { start_date, start_time, end_date, end_time } = formatDate2;\n            const startTime = (/* @__PURE__ */ new Date(`${start_date} ${start_time}`)).getTime();\n            const endTime = (/* @__PURE__ */ new Date(`${end_date} ${end_time}`)).getTime();\n            return [startTime, endTime];\n          } else {\n            const startTime = new Date(formatDate2.start_date).getTime();\n            const endTime = new Date(formatDate2.end_date).getTime();\n            return [startTime, endTime];\n          }\n        }\n        case \"checkbox\":\n          return content === \"Yes\";\n        case \"last_edited_time\":\n          return block.last_edited_time;\n        default:\n          return content;\n      }\n    }\n  } catch (e) {\n  }\n  return null;\n}\n\n// src/normalize-title.ts\nvar normalizeTitle = (title) => {\n  return (title || \"\").replaceAll(\" \", \"-\").replaceAll(\n    /[^\\dA-Za-z\\u3000-\\u303F\\u3041-\\u3096\\u30A1-\\u30FC\\u4E00-\\u9FFF\\uAC00-\\uD7AF-]/g,\n    \"\"\n  ).replaceAll(\"--\", \"-\").replace(/-$/, \"\").replace(/^-/, \"\").trim().toLowerCase();\n};\n\n// src/uuid-to-id.ts\nvar uuidToId = (uuid) => uuid.replaceAll(\"-\", \"\");\n\n// src/get-canonical-page-id.ts\nvar getCanonicalPageId = (pageId, recordMap, { uuid = true } = {}) => {\n  var _a;\n  if (!pageId || !recordMap) return null;\n  const id = uuidToId(pageId);\n  const block = (_a = recordMap.block[pageId]) == null ? void 0 : _a.value;\n  if (block) {\n    const slug = getPageProperty(\"slug\", block, recordMap) || getPageProperty(\"Slug\", block, recordMap) || normalizeTitle(getBlockTitle(block, recordMap));\n    if (slug) {\n      if (uuid) {\n        return `${slug}-${id}`;\n      } else {\n        return slug;\n      }\n    }\n  }\n  return id;\n};\n\n// src/get-date-value.ts\nvar getDateValue = (prop) => {\n  if (prop && Array.isArray(prop)) {\n    if (prop[0] === \"d\") {\n      return prop[1];\n    } else {\n      for (const v of prop) {\n        const value = getDateValue(v);\n        if (value) {\n          return value;\n        }\n      }\n    }\n  }\n  return null;\n};\n\n// src/get-page-breadcrumbs.ts\nvar getPageBreadcrumbs = (recordMap, activePageId) => {\n  var _a;\n  const blockMap = recordMap.block;\n  const breadcrumbs = [];\n  let currentPageId = activePageId;\n  do {\n    const block = (_a = blockMap[currentPageId]) == null ? void 0 : _a.value;\n    if (!block) {\n      break;\n    }\n    const title = getBlockTitle(block, recordMap);\n    const icon = getBlockIcon(block, recordMap);\n    if (!(title || icon)) {\n      break;\n    }\n    breadcrumbs.push({\n      block,\n      active: currentPageId === activePageId,\n      pageId: currentPageId,\n      title,\n      icon\n    });\n    const parentBlock = getBlockParentPage(block, recordMap);\n    const parentId = parentBlock == null ? void 0 : parentBlock.id;\n    if (!parentId) {\n      break;\n    }\n    currentPageId = parentId;\n  } while (true);\n  breadcrumbs.reverse();\n  return breadcrumbs;\n};\n\n// src/get-page-content-block-ids.ts\nvar getPageContentBlockIds = (recordMap, blockId) => {\n  const rootBlockId = blockId || Object.keys(recordMap.block)[0];\n  const contentBlockIds = /* @__PURE__ */ new Set();\n  function addContentBlocks(blockId2) {\n    var _a, _b, _c, _d, _e, _f;\n    if (contentBlockIds.has(blockId2)) return;\n    contentBlockIds.add(blockId2);\n    const block = (_a = recordMap.block[blockId2]) == null ? void 0 : _a.value;\n    if (!block) return;\n    const { content, type, properties, format } = block;\n    if (properties) {\n      for (const key of Object.keys(properties)) {\n        const p = properties[key];\n        if (!p) continue;\n        for (const d of p) {\n          const value2 = (_c = (_b = d == null ? void 0 : d[0]) == null ? void 0 : _b[1]) == null ? void 0 : _c[0];\n          if ((value2 == null ? void 0 : value2[0]) === \"p\" && value2[1]) {\n            addContentBlocks(value2[1]);\n          }\n        }\n        const value = (_e = (_d = p == null ? void 0 : p[0]) == null ? void 0 : _d[1]) == null ? void 0 : _e[0];\n        if ((value == null ? void 0 : value[0]) === \"p\" && value[1]) {\n          addContentBlocks(value[1]);\n        }\n      }\n    }\n    if (format) {\n      const referenceId = (_f = format.transclusion_reference_pointer) == null ? void 0 : _f.id;\n      if (referenceId) {\n        addContentBlocks(referenceId);\n      }\n    }\n    if (!content || !Array.isArray(content)) {\n      return;\n    }\n    if (blockId2 !== rootBlockId) {\n      if (type === \"page\" || type === \"collection_view_page\") {\n        return;\n      }\n    }\n    for (const blockId3 of content) {\n      addContentBlocks(blockId3);\n    }\n  }\n  addContentBlocks(rootBlockId);\n  return Array.from(contentBlockIds);\n};\n\n// src/is-url.ts\nimport { default as default2 } from \"is-url-superb\";\n\n// src/get-page-image-urls.ts\nvar getPageImageUrls = (recordMap, {\n  mapImageUrl\n}) => {\n  const blockIds = Object.keys(recordMap.block);\n  const imageUrls = blockIds.flatMap((blockId) => {\n    var _a, _b, _c, _d, _e, _f, _g, _h, _i, _j, _k;\n    const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;\n    const images = [];\n    if (block) {\n      if (block.type === \"image\") {\n        const signedUrl = (_b = recordMap.signed_urls) == null ? void 0 : _b[block.id];\n        let source = signedUrl || ((_e = (_d = (_c = block.properties) == null ? void 0 : _c.source) == null ? void 0 : _d[0]) == null ? void 0 : _e[0]);\n        if (source == null ? void 0 : source.includes(\"file.notion.so\")) {\n          source = (_h = (_g = (_f = block.properties) == null ? void 0 : _f.source) == null ? void 0 : _g[0]) == null ? void 0 : _h[0];\n        }\n        if (source) {\n          images.push({\n            block,\n            url: source\n          });\n        }\n      }\n      if ((_i = block.format) == null ? void 0 : _i.page_cover) {\n        const source = block.format.page_cover;\n        images.push({\n          block,\n          url: source\n        });\n      }\n      if ((_j = block.format) == null ? void 0 : _j.bookmark_cover) {\n        const source = block.format.bookmark_cover;\n        images.push({\n          block,\n          url: source\n        });\n      }\n      if ((_k = block.format) == null ? void 0 : _k.bookmark_icon) {\n        const source = block.format.bookmark_icon;\n        images.push({\n          block,\n          url: source\n        });\n      }\n      const pageIcon = getBlockIcon(block, recordMap);\n      if (pageIcon && default2(pageIcon)) {\n        images.push({\n          block,\n          url: pageIcon\n        });\n      }\n    }\n    return images;\n  }).filter(Boolean).map(({ block, url }) => mapImageUrl(url, block)).filter(Boolean);\n  return Array.from(new Set(imageUrls));\n};\n\n// src/get-page-title.ts\nimport \"notion-types\";\nfunction getPageTitle(recordMap) {\n  var _a;\n  const rootBlockId = Object.keys(recordMap.block)[0];\n  if (!rootBlockId) return null;\n  const pageBlock = (_a = recordMap.block[rootBlockId]) == null ? void 0 : _a.value;\n  if (pageBlock) {\n    return getBlockTitle(pageBlock, recordMap);\n  }\n  return null;\n}\n\n// src/get-page-tweet-urls.ts\nvar getPageTweetUrls = (recordMap) => {\n  const blockIds = Object.keys(recordMap.block);\n  const tweetUrls = blockIds.map((blockId) => {\n    var _a, _b, _c, _d;\n    const block = (_a = recordMap.block[blockId]) == null ? void 0 : _a.value;\n    if ((block == null ? void 0 : block.type) === \"tweet\") {\n      const tweetUrl = (_d = (_c = (_b = block.properties) == null ? void 0 : _b.source) == null ? void 0 : _c[0]) == null ? void 0 : _d[0];\n      if (tweetUrl) {\n        return tweetUrl;\n      }\n    }\n  }).filter(Boolean);\n  return Array.from(new Set(tweetUrls));\n};\n\n// src/get-page-tweet-ids.ts\nvar getPageTweetIds = (recordMap) => {\n  const tweetUrls = getPageTweetUrls(recordMap);\n  return tweetUrls.map((url) => {\n    try {\n      const u = new URL(url);\n      const parts = u.pathname.split(\"/\");\n      return parts.at(-1);\n    } catch (e) {\n      return;\n    }\n  }).filter(Boolean);\n};\n\n// src/map-image-url.ts\nimport \"notion-types\";\nvar defaultMapImageUrl = (url, block) => {\n  if (!url) {\n    return void 0;\n  }\n  if (url.startsWith(\"data:\")) {\n    return url;\n  }\n  if (url.startsWith(\"https://images.unsplash.com\")) {\n    return url;\n  }\n  try {\n    const u = new URL(url);\n    if (u.pathname.startsWith(\"/secure.notion-static.com\") && u.hostname.endsWith(\".amazonaws.com\")) {\n      if (u.searchParams.has(\"X-Amz-Credential\") && u.searchParams.has(\"X-Amz-Signature\") && u.searchParams.has(\"X-Amz-Algorithm\")) {\n        return url;\n      }\n    }\n    if (u.hostname === \"img.notionusercontent.com\") {\n      return url;\n    }\n  } catch (e) {\n  }\n  if (url.startsWith(\"/images\")) {\n    url = `https://www.notion.so${url}`;\n  }\n  url = `https://www.notion.so${url.startsWith(\"/image\") ? url : `/image/${encodeURIComponent(url)}`}`;\n  const notionImageUrlV2 = new URL(url);\n  let table = block.parent_table === \"space\" ? \"block\" : block.parent_table;\n  if (table === \"collection\" || table === \"team\") {\n    table = \"block\";\n  }\n  notionImageUrlV2.searchParams.set(\"table\", table);\n  notionImageUrlV2.searchParams.set(\"id\", block.id);\n  notionImageUrlV2.searchParams.set(\"cache\", \"v2\");\n  url = notionImageUrlV2.toString();\n  return url;\n};\n\n// src/map-page-url.ts\nvar defaultMapPageUrl = (rootPageId) => (pageId) => {\n  pageId = (pageId || \"\").replaceAll(\"-\", \"\");\n  if (rootPageId && pageId === rootPageId) {\n    return \"/\";\n  } else {\n    return `/${pageId}`;\n  }\n};\n\n// src/merge-record-maps.ts\nimport \"notion-types\";\nfunction mergeRecordMaps(recordMapA, recordMapB) {\n  const mergedRecordMap = {\n    block: {\n      ...recordMapA.block,\n      ...recordMapB.block\n    },\n    collection: {\n      ...recordMapA.collection,\n      ...recordMapB.collection\n    },\n    collection_view: {\n      ...recordMapA.collection_view,\n      ...recordMapB.collection_view\n    },\n    notion_user: {\n      ...recordMapA.notion_user,\n      ...recordMapB.notion_user\n    },\n    collection_query: {\n      ...recordMapA.collection_query,\n      ...recordMapB.collection_query\n    },\n    signed_urls: {\n      ...recordMapA.signed_urls,\n      ...recordMapB.signed_urls\n    },\n    preview_images: {\n      ...recordMapA.preview_images,\n      ...recordMapB.preview_images\n    }\n  };\n  return mergedRecordMap;\n}\n\n// src/normalize-url.ts\nimport memoize from \"memoize\";\nimport normalizeUrlImpl from \"normalize-url\";\nvar normalizeUrl = memoize((url) => {\n  if (!url) {\n    return \"\";\n  }\n  try {\n    if (url.startsWith(\"https://www.notion.so/image/\")) {\n      const u = new URL(url);\n      const subUrl = decodeURIComponent(u.pathname.slice(\"/image/\".length));\n      const normalizedSubUrl = normalizeUrl(subUrl);\n      u.pathname = `/image/${encodeURIComponent(normalizedSubUrl)}`;\n      url = u.toString();\n    }\n    return normalizeUrlImpl(url, {\n      stripProtocol: true,\n      stripWWW: true,\n      stripHash: true,\n      stripTextFragment: true,\n      removeQueryParameters: true\n    });\n  } catch (e) {\n    return \"\";\n  }\n});\nexport {\n  defaultMapImageUrl,\n  defaultMapPageUrl,\n  estimatePageReadTime,\n  estimatePageReadTimeAsHumanizedString,\n  formatDate,\n  formatNotionDateTime,\n  getAllPagesInSpace,\n  getBlockCollectionId,\n  getBlockIcon,\n  getBlockParentPage,\n  getBlockTitle,\n  getCanonicalPageId,\n  getDateValue,\n  getPageBreadcrumbs,\n  getPageContentBlockIds,\n  getPageImageUrls,\n  getPageProperty,\n  getPageTableOfContents,\n  getPageTitle,\n  getPageTweetIds,\n  getPageTweetUrls,\n  getTextContent,\n  idToUuid,\n  default2 as isUrl,\n  mergeRecordMaps,\n  normalizeTitle,\n  normalizeUrl,\n  parsePageId,\n  uuidToId\n};\n//# sourceMappingURL=index.js.map","// src/notion-api.ts\nimport {\n  getBlockCollectionId,\n  getPageContentBlockIds,\n  parsePageId,\n  uuidToId\n} from \"notion-utils\";\nimport { ofetch } from \"ofetch\";\nimport pMap from \"p-map\";\nvar NotionAPI = class {\n  _apiBaseUrl;\n  _authToken;\n  _activeUser;\n  _userTimeZone;\n  _ofetchOptions;\n  constructor({\n    apiBaseUrl = \"https://www.notion.so/api/v3\",\n    authToken,\n    activeUser,\n    userTimeZone = \"America/New_York\",\n    ofetchOptions\n  } = {}) {\n    this._apiBaseUrl = apiBaseUrl;\n    this._authToken = authToken;\n    this._activeUser = activeUser;\n    this._userTimeZone = userTimeZone;\n    this._ofetchOptions = ofetchOptions;\n  }\n  async getPage(pageId, {\n    concurrency = 3,\n    fetchMissingBlocks = true,\n    fetchCollections = true,\n    signFileUrls = true,\n    chunkLimit = 100,\n    chunkNumber = 0,\n    throwOnCollectionErrors = false,\n    collectionReducerLimit = 999,\n    fetchRelationPages = false,\n    ofetchOptions\n  } = {}) {\n    const page = await this.getPageRaw(pageId, {\n      chunkLimit,\n      chunkNumber,\n      ofetchOptions\n    });\n    const recordMap = page?.recordMap;\n    if (!recordMap?.block) {\n      throw new Error(`Notion page not found \"${uuidToId(pageId)}\"`);\n    }\n    recordMap.collection = recordMap.collection ?? {};\n    recordMap.collection_view = recordMap.collection_view ?? {};\n    recordMap.notion_user = recordMap.notion_user ?? {};\n    recordMap.collection_query = {};\n    recordMap.signed_urls = {};\n    if (fetchMissingBlocks) {\n      while (true) {\n        const pendingBlockIds = getPageContentBlockIds(recordMap).filter(\n          (id) => !recordMap.block[id]\n        );\n        if (!pendingBlockIds.length) {\n          break;\n        }\n        const newBlocks = await this.getBlocks(\n          pendingBlockIds,\n          ofetchOptions\n        ).then((res) => res.recordMap.block);\n        recordMap.block = { ...recordMap.block, ...newBlocks };\n      }\n    }\n    const contentBlockIds = getPageContentBlockIds(recordMap);\n    if (fetchCollections) {\n      const allCollectionInstances = contentBlockIds.flatMap((blockId) => {\n        const block = recordMap.block[blockId]?.value;\n        const collectionId = block && (block.type === \"collection_view\" || block.type === \"collection_view_page\") && getBlockCollectionId(block, recordMap);\n        if (collectionId) {\n          return block.view_ids?.map((collectionViewId) => ({\n            collectionId,\n            collectionViewId\n          }));\n        } else {\n          return [];\n        }\n      });\n      await pMap(\n        allCollectionInstances,\n        async (collectionInstance) => {\n          const { collectionId, collectionViewId } = collectionInstance;\n          const collectionView = recordMap.collection_view[collectionViewId]?.value;\n          try {\n            const collectionData = await this.getCollectionData(\n              collectionId,\n              collectionViewId,\n              collectionView,\n              {\n                limit: collectionReducerLimit,\n                ofetchOptions\n              }\n            );\n            recordMap.block = {\n              ...recordMap.block,\n              ...collectionData.recordMap.block\n            };\n            recordMap.collection = {\n              ...recordMap.collection,\n              ...collectionData.recordMap.collection\n            };\n            recordMap.collection_view = {\n              ...recordMap.collection_view,\n              ...collectionData.recordMap.collection_view\n            };\n            recordMap.notion_user = {\n              ...recordMap.notion_user,\n              ...collectionData.recordMap.notion_user\n            };\n            recordMap.collection_query[collectionId] = {\n              ...recordMap.collection_query[collectionId],\n              [collectionViewId]: collectionData.result?.reducerResults\n            };\n          } catch (err) {\n            console.warn(\n              \"NotionAPI collectionQuery error\",\n              { pageId, collectionId, collectionViewId },\n              err.message\n            );\n            if (throwOnCollectionErrors) {\n              throw err;\n            } else {\n              console.error(err);\n            }\n          }\n        },\n        {\n          concurrency\n        }\n      );\n    }\n    if (signFileUrls) {\n      await this.addSignedUrls({ recordMap, contentBlockIds, ofetchOptions });\n    }\n    if (fetchRelationPages) {\n      const newBlocks = await this.fetchRelationPages(recordMap, ofetchOptions);\n      recordMap.block = { ...recordMap.block, ...newBlocks };\n    }\n    return recordMap;\n  }\n  fetchRelationPages = async (recordMap, ofetchOptions) => {\n    const maxIterations = 10;\n    for (let i = 0; i < maxIterations; ++i) {\n      const relationPageIdsThisIteration = /* @__PURE__ */ new Set();\n      for (const blockId of Object.keys(recordMap.block)) {\n        const blockValue = recordMap.block[blockId]?.value;\n        if (blockValue?.parent_table === \"collection\" && blockValue?.parent_id) {\n          const collection = recordMap.collection[blockValue.parent_id]?.value;\n          if (collection?.schema) {\n            const ids = this.extractRelationPageIdsFromBlock(\n              blockValue,\n              collection.schema\n            );\n            for (const id of ids) relationPageIdsThisIteration.add(id);\n          }\n        }\n      }\n      const missingRelationPageIds = Array.from(\n        relationPageIdsThisIteration\n      ).filter((id) => !recordMap.block[id]?.value);\n      if (!missingRelationPageIds.length) break;\n      try {\n        const newBlocks = await this.getBlocks(\n          missingRelationPageIds,\n          ofetchOptions\n        ).then((res) => res.recordMap.block);\n        recordMap.block = { ...recordMap.block, ...newBlocks };\n      } catch (err) {\n        console.warn(\n          \"NotionAPI getBlocks error during fetchRelationPages:\",\n          err\n        );\n      }\n    }\n    return recordMap.block;\n  };\n  extractRelationPageIdsFromBlock = (blockValue, collectionSchema) => {\n    const pageIds = /* @__PURE__ */ new Set();\n    for (const propertyId of Object.keys(blockValue.properties || {})) {\n      const schema = collectionSchema[propertyId];\n      if (schema?.type === \"relation\") {\n        const decorations = blockValue.properties[propertyId];\n        if (Array.isArray(decorations)) {\n          for (const decoration of decorations) {\n            if (Array.isArray(decoration) && decoration.length > 1 && decoration[0] === \"\\u2023\") {\n              const pagePointer = decoration[1]?.[0];\n              if (Array.isArray(pagePointer) && pagePointer.length > 1 && pagePointer[0] === \"p\") {\n                pageIds.add(pagePointer[1]);\n              }\n            }\n          }\n        }\n      }\n    }\n    return pageIds;\n  };\n  async addSignedUrls({\n    recordMap,\n    contentBlockIds,\n    ofetchOptions = {}\n  }) {\n    recordMap.signed_urls = {};\n    if (!contentBlockIds) {\n      contentBlockIds = getPageContentBlockIds(recordMap);\n    }\n    const allFileInstances = contentBlockIds.flatMap((blockId) => {\n      const block = recordMap.block[blockId]?.value;\n      if (block && (block.type === \"pdf\" || block.type === \"audio\" || block.type === \"image\" && block.file_ids?.length || block.type === \"video\" || block.type === \"file\" || block.type === \"page\")) {\n        const source = block.type === \"page\" ? block.format?.page_cover : block.properties?.source?.[0]?.[0];\n        if (source) {\n          if (source.includes(\"secure.notion-static.com\") || source.includes(\"prod-files-secure\") || source.includes(\"attachment:\")) {\n            return {\n              permissionRecord: {\n                table: \"block\",\n                id: block.id\n              },\n              url: source\n            };\n          }\n          return [];\n        }\n      }\n      return [];\n    });\n    if (allFileInstances.length > 0) {\n      try {\n        const { signedUrls } = await this.getSignedFileUrls(\n          allFileInstances,\n          ofetchOptions\n        );\n        if (signedUrls.length === allFileInstances.length) {\n          for (const [i, file] of allFileInstances.entries()) {\n            const signedUrl = signedUrls[i];\n            if (!signedUrl) continue;\n            const blockId = file.permissionRecord.id;\n            if (!blockId) continue;\n            recordMap.signed_urls[blockId] = signedUrl;\n          }\n        }\n      } catch (err) {\n        console.warn(\"NotionAPI getSignedfileUrls error\", err);\n      }\n    }\n  }\n  async getPageRaw(pageId, {\n    ofetchOptions,\n    chunkLimit = 100,\n    chunkNumber = 0\n  } = {}) {\n    const parsedPageId = parsePageId(pageId);\n    if (!parsedPageId) {\n      throw new Error(`invalid notion pageId \"${pageId}\"`);\n    }\n    const body = {\n      pageId: parsedPageId,\n      limit: chunkLimit,\n      chunkNumber,\n      cursor: { stack: [] },\n      verticalColumns: false\n    };\n    return this.fetch({\n      endpoint: \"loadPageChunk\",\n      body,\n      ofetchOptions\n    });\n  }\n  async getCollectionData(collectionId, collectionViewId, collectionView, {\n    limit = 999,\n    searchQuery = \"\",\n    userTimeZone = this._userTimeZone,\n    loadContentCover = true,\n    ofetchOptions\n  } = {}) {\n    const type = collectionView?.type;\n    const isBoardType = type === \"board\";\n    const groupBy = isBoardType ? collectionView?.format?.board_columns_by : collectionView?.format?.collection_group_by;\n    let filters = [];\n    if (collectionView?.format?.property_filters) {\n      filters = collectionView.format?.property_filters.map(\n        (filterObj) => {\n          return {\n            filter: filterObj?.filter?.filter,\n            property: filterObj?.filter?.property\n          };\n        }\n      );\n    }\n    if (collectionView?.query2?.filter?.filters) {\n      filters.push(...collectionView.query2.filter.filters);\n    }\n    let loader = {\n      type: \"reducer\",\n      reducers: {\n        collection_group_results: {\n          type: \"results\",\n          limit,\n          loadContentCover\n        }\n      },\n      sort: [],\n      ...collectionView?.query2,\n      filter: {\n        filters,\n        operator: \"and\"\n      },\n      searchQuery,\n      userTimeZone\n    };\n    if (groupBy) {\n      const groups = collectionView?.format?.board_columns || collectionView?.format?.collection_groups || [];\n      const iterators = [isBoardType ? \"board\" : \"group_aggregation\", \"results\"];\n      const operators = {\n        checkbox: \"checkbox_is\",\n        url: \"string_starts_with\",\n        text: \"string_starts_with\",\n        select: \"enum_is\",\n        multi_select: \"enum_contains\",\n        created_time: \"date_is_within\",\n        undefined: \"is_empty\"\n      };\n      const reducersQuery = {};\n      for (const group of groups) {\n        const {\n          property,\n          value: { value, type: type2 }\n        } = group;\n        for (const iterator of iterators) {\n          const iteratorProps = iterator === \"results\" ? {\n            type: iterator,\n            limit\n          } : {\n            type: \"aggregation\",\n            aggregation: {\n              aggregator: \"count\"\n            }\n          };\n          const isUncategorizedValue = value === void 0;\n          const isDateValue = value?.range;\n          const queryLabel = isUncategorizedValue ? \"uncategorized\" : isDateValue ? value.range?.start_date || value.range?.end_date : value?.value || value;\n          const queryValue = !isUncategorizedValue && (isDateValue || value?.value || value);\n          reducersQuery[`${iterator}:${type2}:${queryLabel}`] = {\n            ...iteratorProps,\n            filter: {\n              operator: \"and\",\n              filters: [\n                {\n                  property,\n                  filter: {\n                    operator: !isUncategorizedValue ? operators[type2] : \"is_empty\",\n                    ...!isUncategorizedValue && {\n                      value: {\n                        type: \"exact\",\n                        value: queryValue\n                      }\n                    }\n                  }\n                }\n              ]\n            }\n          };\n        }\n      }\n      const reducerLabel = isBoardType ? \"board_columns\" : `${type}_groups`;\n      loader = {\n        type: \"reducer\",\n        reducers: {\n          [reducerLabel]: {\n            type: \"groups\",\n            version: \"v2\",\n            groupBy,\n            ...collectionView?.query2?.filter && {\n              filter: collectionView?.query2?.filter\n            },\n            groupSortPreference: groups.map((group) => ({\n              property: group?.property,\n              value: {\n                type: group?.value?.type,\n                value: group?.value?.value\n              }\n            })),\n            limit\n          },\n          ...reducersQuery\n        },\n        ...collectionView?.query2,\n        searchQuery,\n        userTimeZone,\n        //TODO: add filters here\n        filter: {\n          filters,\n          operator: \"and\"\n        }\n      };\n    }\n    return this.fetch({\n      endpoint: \"queryCollection\",\n      body: {\n        collection: {\n          id: collectionId\n        },\n        collectionView: {\n          id: collectionViewId\n        },\n        source: {\n          type: \"collection\",\n          id: collectionId\n        },\n        loader\n      },\n      ofetchOptions: {\n        timeout: 6e4,\n        ...ofetchOptions,\n        params: {\n          // TODO: spread ofetchOptions?.searchParams\n          src: \"initial_load\"\n        }\n      }\n    });\n  }\n  async getUsers(userIds, ofetchOptions) {\n    return this.fetch({\n      endpoint: \"getRecordValues\",\n      body: {\n        requests: userIds.map((id) => ({ id, table: \"notion_user\" }))\n      },\n      ofetchOptions\n    });\n  }\n  async getBlocks(blockIds, ofetchOptions) {\n    return this.fetch({\n      endpoint: \"syncRecordValuesMain\",\n      body: {\n        requests: blockIds.map((blockId) => ({\n          // TODO: when to use table 'space' vs 'block'?\n          table: \"block\",\n          id: blockId,\n          version: -1\n        }))\n      },\n      ofetchOptions\n    });\n  }\n  async getSignedFileUrls(urls, ofetchOptions) {\n    return this.fetch({\n      endpoint: \"getSignedFileUrls\",\n      body: {\n        urls\n      },\n      ofetchOptions\n    });\n  }\n  async search(params, ofetchOptions) {\n    const body = {\n      type: \"BlocksInAncestor\",\n      source: \"quick_find_public\",\n      ancestorId: parsePageId(params.ancestorId),\n      sort: {\n        field: \"relevance\"\n      },\n      limit: params.limit || 20,\n      query: params.query,\n      filters: {\n        isDeletedOnly: false,\n        isNavigableOnly: false,\n        excludeTemplates: true,\n        requireEditPermissions: false,\n        includePublicPagesWithoutExplicitAccess: true,\n        ancestors: [],\n        createdBy: [],\n        editedBy: [],\n        lastEditedTime: {},\n        createdTime: {},\n        ...params.filters\n      }\n    };\n    return this.fetch({\n      endpoint: \"search\",\n      body,\n      ofetchOptions\n    });\n  }\n  async fetch({\n    endpoint,\n    body,\n    ofetchOptions,\n    headers: clientHeaders\n  }) {\n    const headers = {\n      ...clientHeaders,\n      ...this._ofetchOptions?.headers,\n      ...ofetchOptions?.headers,\n      \"Content-Type\": \"application/json\"\n    };\n    if (this._authToken) {\n      headers.cookie = `token_v2=${this._authToken}`;\n    }\n    if (this._activeUser) {\n      headers[\"x-notion-active-user-header\"] = this._activeUser;\n    }\n    const url = `${this._apiBaseUrl}/${endpoint}`;\n    const res = ofetch(url, {\n      method: \"POST\",\n      mode: \"no-cors\",\n      ...this._ofetchOptions,\n      ...ofetchOptions,\n      body,\n      headers\n    });\n    return res;\n  }\n};\nexport {\n  NotionAPI\n};\n//# sourceMappingURL=index.js.map"],"names":[],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,9,10,11,12,13,14,15,16,17,18,19]}